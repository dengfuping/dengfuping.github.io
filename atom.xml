<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Deng | 不搭</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.dengfuping.com/"/>
  <updated>2017-07-09T14:02:09.635Z</updated>
  <id>http://www.dengfuping.com/</id>
  
  <author>
    <name>Deng | 不搭</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript 开发规范</title>
    <link href="http://www.dengfuping.com/2017/07/09/javascript-development-norm/"/>
    <id>http://www.dengfuping.com/2017/07/09/javascript-development-norm/</id>
    <published>2017-07-09T13:59:20.000Z</published>
    <updated>2017-07-09T14:02:09.635Z</updated>
    
    <content type="html"><![CDATA[<p>参考文章：</p>
<p><a href="http://www.cnblogs.com/polk6/p/4660195.html#Menu2-NoteStyle" target="_blank" rel="external">JavaScript 开发规范</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/polk6/p/4660195.html#Menu2-NoteStyle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JavaScript 开发规范&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>五大浏览器内核</title>
    <link href="http://www.dengfuping.com/2017/07/09/browser-kernel/"/>
    <id>http://www.dengfuping.com/2017/07/09/browser-kernel/</id>
    <published>2017-07-09T13:35:39.000Z</published>
    <updated>2017-07-09T14:14:29.956Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器的内核是分为两个部分的，一是 <code>渲染引擎</code>，另一个是 <code>JS引擎</code>。现在 JS 引擎比较独立，内核更加倾向于说渲染引擎。<a id="more"></a></p>
<ol>
<li>Trident 内核：代表作品是IE，因IE捆绑在Windows中，所以占有极高的份额，又称为IE内核或MSHTML，此内核只能用于Windows平台，且不是开源的。代表作品还有腾讯、Maxthon（遨游）、360浏览器等。但由于市场份额比较大，曾经出现脱离了W3C标准的时候，同时IE版本比较多，存在很多的兼容性问题。</li>
<li>Gecko 内核：代表作品是 Firefox，即火狐浏览器。因火狐是其最多的用户，故常被称为 Firefox 内核它是开源的，最大优势是跨平台，在 Microsoft Windows、Linux、MacOS 等主要操作系统中使用。</li>
<li>Webkit 内核：代表作品是 Safari、曾经的 Chrome，是开源的项目。</li>
<li>Presto 内核：代表作品是 Opera，Presto 是由 Opera Software 开发的浏览器排版引擎，它是世界公认最快的渲染速度的引擎。在 2013 年，Opera宣布加入谷歌阵营，弃用了 Presto </li>
<li>Blink 内核：由 Google 和 Opera Software 开发的浏览器排版引擎，2013年4月发布。现在Chrome 内核是 Blink。谷歌还开发了自己的 JS 引擎（V8），使 JS 运行速度极大地提高了</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器的内核是分为两个部分的，一是 &lt;code&gt;渲染引擎&lt;/code&gt;，另一个是 &lt;code&gt;JS引擎&lt;/code&gt;。现在 JS 引擎比较独立，内核更加倾向于说渲染引擎。
    
    </summary>
    
      <category term="前端开发" scheme="http://www.dengfuping.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端开发" scheme="http://www.dengfuping.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="浏览器" scheme="http://www.dengfuping.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>javascript-caller-and-callee</title>
    <link href="http://www.dengfuping.com/2017/07/09/javascript-caller-and-callee/"/>
    <id>http://www.dengfuping.com/2017/07/09/javascript-caller-and-callee/</id>
    <published>2017-07-09T09:44:43.000Z</published>
    <updated>2017-07-09T13:59:41.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h2><p>caller 是函数对象的一个属性，返回一个函数的引用，该函数调用了当前函数。使用这个属性是要注意：</p>
<ul>
<li>这个属性只有当函数在执行时才有用；</li>
<li>如果在 JavaScript 程序中，函数是由顶层调用的，则返回 null。<a id="more"></a></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;   </div><div class="line">    <span class="built_in">console</span>.log(a.caller);   </div><div class="line">&#125;</div><div class="line">   </div><div class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;   </div><div class="line">    a();   </div><div class="line">&#125;</div><div class="line">   </div><div class="line">b();</div></pre></td></tr></table></figure>
<p>输出的结果为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;   </div><div class="line">    a();   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但若是将代码改为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;   </div><div class="line">    <span class="built_in">console</span>.log(a.caller);   </div><div class="line">&#125;</div><div class="line">   </div><div class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;   </div><div class="line">    a();   </div><div class="line">&#125;</div><div class="line">   </div><div class="line">a();</div></pre></td></tr></table></figure>
<p>输出的结果为 <code>null</code>。</p>
<h2 id="callee"><a href="#callee" class="headerlink" title="callee"></a>callee</h2><p>callee 返回正在执行的函数本身的引用，它是 arguments 的一个属性。使用 callee 时要注意:</p>
<ul>
<li>这个属性只有在函数执行时才有效；</li>
<li>它有一个 length 属性，可以用来获得形参的个数，因此可以用来比较形参和实参个数是否一致，即比较 arguments.length 是否等于 arguments.callee.length；</li>
<li>它可以用来递归匿名函数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;   </div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee);   </div><div class="line">&#125;</div><div class="line">   </div><div class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;   </div><div class="line">    a();   </div><div class="line">&#125;</div><div class="line">   </div><div class="line">b();</div></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;   </div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee);   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;caller&quot;&gt;&lt;a href=&quot;#caller&quot; class=&quot;headerlink&quot; title=&quot;caller&quot;&gt;&lt;/a&gt;caller&lt;/h2&gt;&lt;p&gt;caller 是函数对象的一个属性，返回一个函数的引用，该函数调用了当前函数。使用这个属性是要注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这个属性只有当函数在执行时才有用；&lt;/li&gt;
&lt;li&gt;如果在 JavaScript 程序中，函数是由顶层调用的，则返回 null。
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript：单例模式的实现方法</title>
    <link href="http://www.dengfuping.com/2017/06/14/javascript-singleton/"/>
    <id>http://www.dengfuping.com/2017/06/14/javascript-singleton/</id>
    <published>2017-06-14T01:07:34.000Z</published>
    <updated>2017-06-14T01:10:48.350Z</updated>
    
    <content type="html"><![CDATA[<p>参考文章：</p>
<p><a href="https://juejin.im/post/593e116c61ff4b006c995c93?utm_source=gold_browser_extension" target="_blank" rel="external">JS 的平凡之路 – 单例模式的各种实现方式</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/593e116c61ff4b006c995c93?utm_source=gold_browser_extension&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;J
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript：链式调用</title>
    <link href="http://www.dengfuping.com/2017/05/23/javascript-call-by-chaining/"/>
    <id>http://www.dengfuping.com/2017/05/23/javascript-call-by-chaining/</id>
    <published>2017-05-23T06:48:49.000Z</published>
    <updated>2017-05-23T09:00:22.148Z</updated>
    
    <content type="html"><![CDATA[<p>最近在研究 jQuery 的源码，发现自己对其链式调用还理解不是很深。今天趁此机会，就来谈一谈 JavaScript 中的链式调用<br>链式调用我们平常用到很多，比如 jQuery 中的$(ele).show().find(child).hide()，再比如angularjs中的$http.get(url).success(fn_s).error(fn_e)。但这都是已经包装好的链式调用，我们只能体会链式调用带来的方便，却不知道形成这样一条函数链的原理是什么。<a id="more"></a></p>
<p>　　随着链式调用的普及，实现的方案也越来越多。最常见的，是jQuery直接返回this的方式，underscore的可选式的方式，和lodash惰性求值的方式。我们分别来了解，并逐个完成它们的demo。</p>
<p>参考文章：</p>
<p><a href="http://www.cnblogs.com/tarol/p/5336666.html" target="_blank" rel="external">玩一把JS的链式调用</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在研究 jQuery 的源码，发现自己对其链式调用还理解不是很深。今天趁此机会，就来谈一谈 JavaScript 中的链式调用&lt;br&gt;链式调用我们平常用到很多，比如 jQuery 中的$(ele).show().find(child).hide()，再比如angularjs中的$http.get(url).success(fn_s).error(fn_e)。但这都是已经包装好的链式调用，我们只能体会链式调用带来的方便，却不知道形成这样一条函数链的原理是什么。
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript：事件代理（委托）的兼容性</title>
    <link href="http://www.dengfuping.com/2017/05/14/javascript-event-delegate-compatibility/"/>
    <id>http://www.dengfuping.com/2017/05/14/javascript-event-delegate-compatibility/</id>
    <published>2017-05-14T03:46:37.000Z</published>
    <updated>2017-05-14T04:31:30.635Z</updated>
    
    <content type="html"><![CDATA[<p>由于网上的很多文章都介绍了 js 中的事件代理，因此本文只探讨一些关于事件代理中容易被忽视的两个问题，那就是原生 js 实现和其在浏览器中的兼容性问题。</p>
<p>相信很多人都知道，借助 jQuery 中的 delegate() 和 on() 函数我们可以轻松实现事件代理，具体使用方式可以参考我的另外一篇文章：<a href="http://www.dengfuping.com/2017/04/24/javascript-jquery-bind-on-delegate/">jQuery 事件绑定函数解析：bind, on, delegate</a> </p>
<p>但今天我们要探讨的是如何使用原生 js 来实现事件代理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>事件代理<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第一个li元素<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第二个li元素<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第三个li元素<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第四个li元素<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第五个li元素<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">'ul'</span>);</div><div class="line">    ul.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> myEvent = event || <span class="built_in">window</span>.event;</div><div class="line">        <span class="keyword">var</span> target = myEvent.target || myEvent.srcElement;</div><div class="line">        <span class="keyword">if</span> (target.nodeName.toLocaleLowerCase() == <span class="string">'li'</span>)&#123;</div><div class="line">            alert(target.firstChild.nodeValue);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>针对上面的代码做几点说明：</p>
<ul>
<li>event对象用于存储事件的数据，例如触发事件的元素、鼠标的位置及状态、按下的键等等；event对象只在事件发生的过程中才有效。</li>
<li>firefox 跟其他浏览器中使用的 event 的方法不同，其他浏览器中的 event 是全局变量，随时可用；firefox需要在事件方法的参数里写 event 才能用，是运行时的临时变量。也就是说，在其他浏览器中，是 window.event，而在 firefox 中是 event；</li>
<li>要获取事件目标，其它浏览器调用的是 event.target 属性，而在 IE 中则需要调用的是 event.srcElement 属性。</li>
</ul>
<p>所以在使用原生的 js 实现事件代理时既要考虑 firefox 下的兼容性又要考虑 IE 下的兼容性，这也是面试和实际应用当中会遇到的问题。而在使用 jQuery 时它会帮你做这些兼容性处理。进一步来看，这也可以看成是 jQuery 实现事件委托的基本原理。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于网上的很多文章都介绍了 js 中的事件代理，因此本文只探讨一些关于事件代理中容易被忽视的两个问题，那就是原生 js 实现和其在浏览器中的兼容性问题。&lt;/p&gt;
&lt;p&gt;相信很多人都知道，借助 jQuery 中的 delegate() 和 on() 函数我们可以轻松实现事件代
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>网络安全之 CSRF 攻击</title>
    <link href="http://www.dengfuping.com/2017/05/11/web-security-csrf-attack/"/>
    <id>http://www.dengfuping.com/2017/05/11/web-security-csrf-attack/</id>
    <published>2017-05-11T14:56:32.000Z</published>
    <updated>2017-05-11T15:06:09.338Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>跨站请求伪造（Cross-site request forgery），通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。</p>
<blockquote>
<p>跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p>
</blockquote>
<p>参考文章：</p>
<p><a href="https://juejin.im/post/583d6384a22b9d006a93c868" target="_blank" rel="external">Token 验证防止 CSRF 攻击的原理</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;跨站请求伪造（Cross-site request forgery），通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 
    
    </summary>
    
      <category term="网络安全" scheme="http://www.dengfuping.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="XSS" scheme="http://www.dengfuping.com/tags/XSS/"/>
    
      <category term="网络安全" scheme="http://www.dengfuping.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>网络安全之 XSS 攻击</title>
    <link href="http://www.dengfuping.com/2017/05/11/web-security-xss-attack/"/>
    <id>http://www.dengfuping.com/2017/05/11/web-security-xss-attack/</id>
    <published>2017-05-11T14:25:55.000Z</published>
    <updated>2017-05-11T15:03:03.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>XSS，全称是跨站脚本攻击（Cross-site scripting），为了不和层叠样式表(CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意的 script 代码，当用户浏览该页之时，嵌入其中的 script 代码会被执行，从而达到恶意攻击用户的目的，如盗取用户的 cookie 等敏感信息</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="存储型-XSS"><a href="#存储型-XSS" class="headerlink" title="存储型 XSS"></a>存储型 XSS</h3><p>数据库中存有的存在XSS攻击的数据，返回给客户端。若数据未经过任何转义。被浏览器渲染。就可能导致XSS攻击。</p>
<h3 id="反射型-XSS"><a href="#反射型-XSS" class="headerlink" title="反射型 XSS"></a>反射型 XSS</h3><p>将用户输入的存在XSS攻击的数据，发送给后台，后台并未对数据进行存储，也未经过任何过滤，直接返回给客户端。被浏览器渲染。就可能导致XSS攻击。</p>
<h3 id="DOM-XSS"><a href="#DOM-XSS" class="headerlink" title="DOM XSS"></a>DOM XSS</h3><p>纯粹发生在客户端的XSS攻击，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http:<span class="comment">//www.some.site/page.html?default=French</span></div></pre></td></tr></table></figure>
<p>页面代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt; </div><div class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;OPTION value=1&gt;"</span>+<span class="built_in">document</span>.location.href.substring(<span class="built_in">document</span>.location.href.indexOf(<span class="string">"default="</span>)+<span class="number">8</span>)+<span class="string">"&lt;/OPTION&gt;"</span>);  </div><div class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;OPTION value=2&gt;English&lt;/OPTION&gt;"</span>);    </div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>该XSS攻击实现条件：</p>
<p>（1）用户点击了如下连接：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http:<span class="comment">//www.some.site/page.html?default=&lt;script&gt;alert(document.cookie)&lt;/script&gt;</span></div></pre></td></tr></table></figure>
<p>（2）后台对URL参数未做任何过滤处理，返回给客户端，前端直接从url上获取参数。</p>
<p>（3）打开网址的浏览器是低版本浏览器，常见ie8以下。</p>
<p>满足以上三者，就会导致URL上的js代码执行:alert(document.cookie)，但是攻击者可以利用这个，做你无法想象的事情。在现代浏览器中，已经做了xss过滤，一旦检测到xss,会提示报错如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">The XSS Auditor refused to execute a script <span class="keyword">in</span> <span class="string">'file:///C:/Users/summerhxji/Desktop/taobao/xss.html?default=%3Cscript%3Ealert(document.cookie)%3C/script%3E'</span> because its source code was found within the request. The auditor was enabled <span class="keyword">as</span> the server did not send an <span class="string">'X-XSS-Protection'</span> header.</div><div class="line">(anonymous) @ xss.html?<span class="keyword">default</span>=<span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="built_in">document</span>.cookie)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>以上便是学术上的划分的XSS攻击类型，2、3类型其实都是反射型的攻击。了解了这些，意识到XSS攻击无处不在啊。</p>
<h2 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h2><p>（1）从输入和输出进行过滤和转义。可以使用 htmlspecialchars() 等函数进行过滤转义，当然，一些文件上传等，也可能会造成此攻击，要限制上传文件的类型，比如只能传图片等。</p>
<p>参考文章：</p>
<p><a href="https://www.zhuyingda.com/blog/article.html?id=2" target="_blank" rel="external">XSS漏洞的原理</a></p>
<p><a href="http://mp.weixin.qq.com/s/6ChuUdOm7vej8vQ3dbC8fw" target="_blank" rel="external">XSS攻击和防御详解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;XSS，全称是跨站脚本攻击（Cross-site scripting），为了不和层叠样式表(CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS
    
    </summary>
    
      <category term="网络安全" scheme="http://www.dengfuping.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="XSS" scheme="http://www.dengfuping.com/tags/XSS/"/>
    
      <category term="网络安全" scheme="http://www.dengfuping.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>React 虚拟 DOM 浅析</title>
    <link href="http://www.dengfuping.com/2017/05/10/react-virtual-dom/"/>
    <id>http://www.dengfuping.com/2017/05/10/react-virtual-dom/</id>
    <published>2017-05-10T02:45:47.000Z</published>
    <updated>2017-05-10T07:58:20.540Z</updated>
    
    <content type="html"><![CDATA[<p>在 Web 开发中，需要将数据的变化实时反映到UI上，这时就需要对 DOM 进行操作，但是复杂或频繁的DOM操作通常是性能瓶颈产生的原因，为此，React 引入了虚拟 DOM（Virtual DOM）的机制。<a id="more"></a></p>
<h2 id="什么是虚拟-DOM"><a href="#什么是虚拟-DOM" class="headerlink" title="什么是虚拟 DOM"></a>什么是虚拟 DOM</h2><p>在React中，render执行的结果得到的并不是真正的DOM节点，结果仅仅是轻量级的JavaScript对象，我们称之为virtual DOM。</p>
<p>虚拟DOM是React的一大亮点，具有batching(批处理)和高效的Diff算法。这让我们可以无需担心性能问题而”毫无顾忌”的随时“刷新”整个页面，由虚拟 DOM来确保只对界面上真正变化的部分进行实际的DOM操作。在实际开发中基本无需关心虚拟DOM是如何运作的，但是理解其运行机制不仅有助于更好的理解React组件的生命周期，而且对于进一步优化 React程序也会有很大帮助。</p>
<h2 id="虚拟DOM-vs-直接操作原生DOM？"><a href="#虚拟DOM-vs-直接操作原生DOM？" class="headerlink" title="虚拟DOM vs 直接操作原生DOM？"></a>虚拟DOM vs 直接操作原生DOM？</h2><p>如果没有 Virtual DOM，简单来说就是直接重置 innerHTML。这样操作，在一个大型列表所有数据都变了的情况下，还算是合理，但是，当只有一行数据发生变化时，它也需要重置整个 innerHTML，这时候显然就造成了大量浪费。</p>
<p>比较innerHTML 和Virtual DOM 的重绘过程如下：</p>
<ul>
<li>innerHTML: render html string + 重新创建所有 DOM 元素</li>
<li>Virtual DOM: render Virtual DOM + diff + 必要的 DOM 更新</li>
</ul>
<p>和 DOM 操作比起来，js 计算是非常便宜的。Virtual DOM render + diff 显然比渲染 html 字符串要慢，但是，它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。当然，曾有人做过验证说React的性能不如直接操作真实DOM，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Raw</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> data = _buildData(),</div><div class="line">        html = <span class="string">""</span>;</div><div class="line">    ...</div><div class="line">    for(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;data.length; i++) &#123;</div><div class="line">        <span class="keyword">var</span> render = template;</div><div class="line">        render = render.replace(<span class="string">"&#123;&#123;className&#125;&#125;"</span>, <span class="string">""</span>);</div><div class="line">        render = render.replace(<span class="string">"&#123;&#123;label&#125;&#125;"</span>, data[i].label);</div><div class="line">        html += render;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    container.innerHTML = html;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该测试用例中虽然构造了一个包含1000个Tag的String，并把它添加到DOM树中，但是只做了一次DOM操作。然而，在实际开发过程中，这1000个元素更新可能分布在20个逻辑块中，每个逻辑块中包含50个元素，当页面需要更新时，都会引起DOM树的更新，上述代码就近似变成了如下格式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Raw</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> data = _buildData(),</div><div class="line">        html = <span class="string">""</span>;</div><div class="line">    ...</div><div class="line">    for(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;data.length; i++) &#123;</div><div class="line">        <span class="keyword">var</span> render = template;</div><div class="line">        render = render.replace(<span class="string">"&#123;&#123;className&#125;&#125;"</span>, <span class="string">""</span>);</div><div class="line">        render = render.replace(<span class="string">"&#123;&#123;label&#125;&#125;"</span>, data[i].label);</div><div class="line">        html += render;</div><div class="line">        <span class="keyword">if</span>(!(i % <span class="number">50</span>)) &#123;</div><div class="line">            container.innerHTML = html;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样来看，React的性能就远胜于原生DOM操作了。而且，DOM 完全不属于Javascript (也不在Javascript 引擎中在)。Javascript 其实是一个非常独立的引擎，DOM其实是浏览器引出的一组让Javascript操作HTML文档的API而已。在即时编译的时代，调用DOM的开销是很大的。而Virtual DOM的执行完全都在Javascript 引擎中，完全不会有这个开销。</p>
<p>React.js 相对于直接操作原生DOM有很大的性能优势， 很大程度上都要归功于virtual DOM的batching 和diff。batching把所有的DOM操作搜集起来，一次性提交给真实的DOM。diff算法时间复杂度也从标准的的Diff算法的O(n^3)降到了O(n)。这里留到下一次博客单独讲。</p>
<h2 id="虚拟-DOM-vs-MVVM"><a href="#虚拟-DOM-vs-MVVM" class="headerlink" title="虚拟 DOM vs MVVM"></a>虚拟 DOM vs MVVM</h2><p>相比起 React，其他 MVVM 系框架比如 Angular, Knockout 以及 Vue、Avalon 采用的都是数据绑定：通过 Directive/Binding 对象，观察数据变化并保留对实际 DOM 元素的引用，当有数据变化时进行对应的操作。MVVM 的变化检查是数据层面的，而 React 的检查是 DOM 结构层面的。MVVM 的性能也根据变动检测的实现原理有所不同：Angular 的脏检查使得任何变动都有固定的 O(watcher count) 的代价；Knockout/Vue/Avalon 都采用了依赖收集，在 js 和 DOM 层面都是 O(change)：</p>
<ul>
<li>脏检查：scope digest + 必要 DOM 更新</li>
<li>依赖收集：重新收集依赖 + 必要 DOM 更新</li>
</ul>
<p>可以看到，Angular 最不效率的地方在于任何小变动都有的和 watcher 数量相关的性能代价。但是！当所有数据都变了的时候，Angular 其实并不吃亏。依赖收集在初始化和数据变化的时候都需要重新收集依赖，这个代价在小量更新的时候几乎可以忽略，但在数据量庞大的时候也会产生一定的消耗。</p>
<p>MVVM 渲染列表的时候，由于每一行都有自己的数据作用域，所以通常都是每一行有一个对应的 ViewModel 实例，或者是一个稍微轻量一些的利用原型继承的 “scope” 对象，但也有一定的代价。所以，MVVM 列表渲染的初始化几乎一定比 React 慢，因为创建 ViewModel / scope 实例比起 Virtual DOM 来说要昂贵很多。这里所有 MVVM 实现的一个共同问题就是在列表渲染的数据源变动时，尤其是当数据是全新的对象时，如何有效地复用已经创建的 ViewModel 实例和 DOM 元素。假如没有任何复用方面的优化，由于数据是 “全新” 的，MVVM 实际上需要销毁之前的所有实例，重新创建所有实例，最后再进行一次渲染！这就是为什么题目里链接的 angular/knockout 实现都相对比较慢。相比之下，React 的变动检查由于是 DOM 结构层面的，即使是全新的数据，只要最后渲染结果没变，那么就不需要做无用功。</p>
<p>Angular 和 Vue 都提供了列表重绘的优化机制，也就是 “提示” 框架如何有效地复用实例和 DOM 元素。比如数据库里的同一个对象，在两次前端 API 调用里面会成为不同的对象，但是它们依然有一样的 uid。这时候你就可以提示 track by uid 来让 Angular 知道，这两个对象其实是同一份数据。那么原来这份数据对应的实例和 DOM 元素都可以复用，只需要更新变动了的部分。或者，你也可以直接 track by $index 来进行 “原地复用”：直接根据在数组里的位置进行复用。在题目给出的例子里，如果 angular 实现加上 track by $index 的话，后续重绘是不会比 React 慢多少的。甚至在 dbmonster 测试中，Angular 和 Vue 用了 track by $index 以后都比 React 快: dbmon (注意 Angular 默认版本无优化，优化过的在下面）</p>
<p>在比较性能的时候，要分清楚初始渲染、小量数据更新、大量数据更新这些不同的场合。Virtual DOM、脏检查 MVVM、数据收集 MVVM 在不同场合各有不同的表现和不同的优化需求。Virtual DOM 为了提升小量数据更新时的性能，也需要针对性的优化，比如 shouldComponentUpdate 或是 immutable data。</p>
<ul>
<li>初始渲染：Virtual DOM &gt; 脏检查 &gt;= 依赖收集</li>
<li>小量数据更新：依赖收集 &gt;&gt; Virtual DOM + 优化 &gt; 脏检查（无法优化） &gt; Virtual DOM 无优化</li>
<li>大量数据更新：脏检查 + 优化 &gt;= 依赖收集 + 优化 &gt; Virtual DOM（无法/无需优化）&gt;&gt; MVVM 无优化</li>
</ul>
<h2 id="对-React-虚拟-DOM-的误解"><a href="#对-React-虚拟-DOM-的误解" class="headerlink" title="对 React 虚拟 DOM 的误解"></a>对 React 虚拟 DOM 的误解</h2><p>React 从来没有说过 “React 比原生操作 DOM 快”。React给我们的保证是，在不需要手动优化的情况下，它依然可以给我们提供过得去的性能。</p>
<p>React掩盖了底层的 DOM 操作，可以用更声明式的方式来描述我们目的，从而让代码更容易维护。下面还是借鉴了知乎上的回答：没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的。针对任何一个 benchmark，我都可以写出比任何框架更快的手动优化，但是那有什么意义呢？在构建一个实际应用的时候，你难道为每一个地方都去做手动优化吗？出于可维护性的考虑，这显然不可能。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Web 开发中，需要将数据的变化实时反映到UI上，这时就需要对 DOM 进行操作，但是复杂或频繁的DOM操作通常是性能瓶颈产生的原因，为此，React 引入了虚拟 DOM（Virtual DOM）的机制。
    
    </summary>
    
      <category term="React" scheme="http://www.dengfuping.com/categories/React/"/>
    
    
      <category term="React" scheme="http://www.dengfuping.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript：实现类继承的三种方法</title>
    <link href="http://www.dengfuping.com/2017/05/10/javascript-class-inheritence/"/>
    <id>http://www.dengfuping.com/2017/05/10/javascript-class-inheritence/</id>
    <published>2017-05-10T00:05:05.000Z</published>
    <updated>2017-05-10T02:49:58.989Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、通过扩展-Object-实现"><a href="#一、通过扩展-Object-实现" class="headerlink" title="一、通过扩展 Object 实现"></a>一、通过扩展 Object 实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义一个父类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">add</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.add = add;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 定义一个子类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 定义一个全局都可以用的继承方法</span></div><div class="line"><span class="built_in">Object</span>.prototype.extend = <span class="function"><span class="keyword">function</span>(<span class="params">ParentObj</span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> ParentObj)&#123;</div><div class="line">        <span class="keyword">this</span>[i] = ParentObj[i]</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Child.extend(Parent(<span class="string">'China'</span>)); <span class="comment">// 使用我们的方法进行继承</span></div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Child(<span class="string">'lemon'</span>)   <span class="comment">// 实例化对象（初始化数据）</span></div><div class="line"><span class="built_in">console</span>.log(obj.add);  <span class="comment">// 此时我们就可以调用父类中的方法或属性了，输出结果：China</span></div></pre></td></tr></table></figure>
<p>这种方法的原理是通过 <code>浅拷贝</code> 实现的，实际上是将父类的所以属性复制到子类当中，从而使得子类可以访问父类的属性。<a id="more"></a></p>
<p>##</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>##</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、通过扩展-Object-实现&quot;&gt;&lt;a href=&quot;#一、通过扩展-Object-实现&quot; class=&quot;headerlink&quot; title=&quot;一、通过扩展 Object 实现&quot;&gt;&lt;/a&gt;一、通过扩展 Object 实现&lt;/h2&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 定义一个父类&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Parent&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;add&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.add = add;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 定义一个子类&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Child&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 定义一个全局都可以用的继承方法&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.prototype.extend = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;ParentObj&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; ParentObj)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;[i] = ParentObj[i]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Child.extend(Parent(&lt;span class=&quot;string&quot;&gt;&#39;China&#39;&lt;/span&gt;)); &lt;span class=&quot;comment&quot;&gt;// 使用我们的方法进行继承&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Child(&lt;span class=&quot;string&quot;&gt;&#39;lemon&#39;&lt;/span&gt;)   &lt;span class=&quot;comment&quot;&gt;// 实例化对象（初始化数据）&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(obj.add);  &lt;span class=&quot;comment&quot;&gt;// 此时我们就可以调用父类中的方法或属性了，输出结果：China&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种方法的原理是通过 &lt;code&gt;浅拷贝&lt;/code&gt; 实现的，实际上是将父类的所以属性复制到子类当中，从而使得子类可以访问父类的属性。
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript：继承方式</title>
    <link href="http://www.dengfuping.com/2017/05/09/javascript-inheritance/"/>
    <id>http://www.dengfuping.com/2017/05/09/javascript-inheritance/</id>
    <published>2017-05-09T09:08:47.000Z</published>
    <updated>2017-05-23T06:54:19.359Z</updated>
    
    <content type="html"><![CDATA[<p>参考文章：</p>
<p><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="external">阮一峰：JavaScript 构造函数的继承</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html" target="_blank" rel="external">阮一峰：非构造函数的继承</a></p>
<p><a href="http://dudodo.cc/2017/04/11/%E7%90%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/" target="_blank" rel="external">理解 JS 中的继承</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/24964910?refer=muyichuanqi" target="_blank" rel="external">js原型链继承，借用构造函数继承,组合继承，寄生式继承，寄生组合继承</a><br><a id="more"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html&quot;&gt;阮一峰：JavaScript 构造函数的继承&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html&quot;&gt;阮一峰：非构造函数的继承&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dudodo.cc/2017/04/11/%E7%90%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/&quot;&gt;理解 JS 中的继承&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24964910?refer=muyichuanqi&quot;&gt;js原型链继承，借用构造函数继承,组合继承，寄生式继承，寄生组合继承&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript：闭包</title>
    <link href="http://www.dengfuping.com/2017/05/06/javascript-closure/"/>
    <id>http://www.dengfuping.com/2017/05/06/javascript-closure/</id>
    <published>2017-05-06T10:32:37.000Z</published>
    <updated>2017-05-09T09:19:19.346Z</updated>
    
    <content type="html"><![CDATA[<p>一、什么是闭包？闭包有什么好处？使用闭包要注意什么？</p>
<p>闭包：函数嵌套函数，内部函数可以引用外部函数的参数和变量，变量和参数不会被垃圾回收机制所回收</p>
<p>好处：<br>（1）希望一个变量长期驻扎在内存之中</p>
<p>（2）避免全局变量的污染</p>
<p>（3）私有成员的存在</p>
<p>注意：可能会造成内存泄漏<br><a id="more"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、什么是闭包？闭包有什么好处？使用闭包要注意什么？&lt;/p&gt;
&lt;p&gt;闭包：函数嵌套函数，内部函数可以引用外部函数的参数和变量，变量和参数不会被垃圾回收机制所回收&lt;/p&gt;
&lt;p&gt;好处：&lt;br&gt;（1）希望一个变量长期驻扎在内存之中&lt;/p&gt;
&lt;p&gt;（2）避免全局变量的污染&lt;/p&gt;
&lt;p&gt;（3）私有成员的存在&lt;/p&gt;
&lt;p&gt;注意：可能会造成内存泄漏&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CSS（四）：垂直居中常用方法</title>
    <link href="http://www.dengfuping.com/2017/05/06/css-vertical-align/"/>
    <id>http://www.dengfuping.com/2017/05/06/css-vertical-align/</id>
    <published>2017-05-06T10:11:45.000Z</published>
    <updated>2017-05-06T10:25:59.697Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单行文本"><a href="#单行文本" class="headerlink" title="单行文本"></a>单行文本</h2><p>若元素是单行文本, 则可设置 line-height 等于父元素高度</p>
<h2 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h2><p>（1）使用 <code>flex</code> 布局，给 <code>父元素</code> 设置如下属性：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.parent</span> &#123;</div><div class="line">    <span class="attribute">display</span>: flex;</div><div class="line">    <span class="attribute">align-items</span>: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单行文本&quot;&gt;&lt;a href=&quot;#单行文本&quot; class=&quot;headerlink&quot; title=&quot;单行文本&quot;&gt;&lt;/a&gt;单行文本&lt;/h2&gt;&lt;p&gt;若元素是单行文本, 则可设置 line-height 等于父元素高度&lt;/p&gt;
&lt;h2 id=&quot;块级元素&quot;&gt;&lt;a href=&quot;
    
    </summary>
    
      <category term="CSS" scheme="http://www.dengfuping.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://www.dengfuping.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS（三）：水平居中常用方法</title>
    <link href="http://www.dengfuping.com/2017/05/06/css-horizontal-align/"/>
    <id>http://www.dengfuping.com/2017/05/06/css-horizontal-align/</id>
    <published>2017-05-06T09:49:42.000Z</published>
    <updated>2017-05-06T10:29:10.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h2><p>给其 <code>父元素</code> 设置 <code>text-align: center</code> ，即可实现行内元素水平居中。</p>
<h2 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h2><p>（1）给 <code>该元素</code> 设置 <code>margin: 0 auto</code> 即可实现块级元素水平居中。适用于 <code>定宽块状元素</code> 。</p>
<p>（2）使用 <code>flex</code> 布局，给 <code>父元素</code> 设置如下属性：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.parent</span> &#123;</div><div class="line">    <span class="attribute">display</span>: flex;</div><div class="line">    <span class="attribute">justify-content</span>: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;行内元素&quot;&gt;&lt;a href=&quot;#行内元素&quot; class=&quot;headerlink&quot; title=&quot;行内元素&quot;&gt;&lt;/a&gt;行内元素&lt;/h2&gt;&lt;p&gt;给其 &lt;code&gt;父元素&lt;/code&gt; 设置 &lt;code&gt;text-align: center&lt;/code&gt; ，即可实现行内
    
    </summary>
    
      <category term="CSS" scheme="http://www.dengfuping.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://www.dengfuping.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS（二）：BFC 深入理解</title>
    <link href="http://www.dengfuping.com/2017/05/04/css-BFC/"/>
    <id>http://www.dengfuping.com/2017/05/04/css-BFC/</id>
    <published>2017-05-04T08:54:58.000Z</published>
    <updated>2017-05-06T09:54:21.246Z</updated>
    
    <content type="html"><![CDATA[<p>请参考文章：<a href="https://juejin.im/post/5909db2fda2f60005d2093db" target="_blank" rel="external">布局概念之关于CSS-BFC深入理解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;请参考文章：&lt;a href=&quot;https://juejin.im/post/5909db2fda2f60005d2093db&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;布局概念之关于CSS-BFC深入理解&lt;/a&gt;&lt;/p&gt;

    
    </summary>
    
      <category term="CSS" scheme="http://www.dengfuping.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://www.dengfuping.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Javascript：null 和 undefined 用法解析</title>
    <link href="http://www.dengfuping.com/2017/05/02/javascript-null-and-undefined/"/>
    <id>http://www.dengfuping.com/2017/05/02/javascript-null-and-undefined/</id>
    <published>2017-05-02T02:10:02.000Z</published>
    <updated>2017-05-02T10:15:37.173Z</updated>
    
    <content type="html"><![CDATA[<p>目前，<code>null</code> 和 <code>undefined</code> 基本是同义的，只有一些细微的差别。</p>
<h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><p>null表示”没有对象”，即该处不应该有值。典型用法是：</p>
<p>（1） 作为函数的参数，表示该函数的参数不是对象。</p>
<p>（2） 作为对象原型链的终点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype);   <span class="comment">// null</span></div><div class="line"><span class="comment">// 说明 Object.prototype.__proto__ = null</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h2><p>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：</p>
<p>（1）变量被声明了，但没有赋值时，就等于undefined。</p>
<p>（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。</p>
<p>（3）对象没有赋值的属性，该属性的值为undefined。</p>
<p>（4）函数没有返回值时，默认返回undefined。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i;</div><div class="line">i <span class="comment">// undefined</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;<span class="built_in">console</span>.log(x)&#125;</div><div class="line">f() <span class="comment">// undefined</span></div><div class="line"></div><div class="line"><span class="keyword">var</span>  o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">o.p <span class="comment">// undefined</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> x = f();</div><div class="line">x <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前，&lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 基本是同义的，只有一些细微的差别。&lt;/p&gt;
&lt;h2 id=&quot;null&quot;&gt;&lt;a href=&quot;#null&quot; class=&quot;headerlink&quot; title=&quot;null&quot;&gt;&lt;/a&gt;null&lt;/h2&gt;&lt;p&gt;null表示”没有对象”，即该处不应该有值。典型用法是：&lt;/p&gt;
&lt;p&gt;（1） 作为函数的参数，表示该函数的参数不是对象。&lt;/p&gt;
&lt;p&gt;（2） 作为对象原型链的终点。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.getPrototypeOf(&lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.prototype);   &lt;span class=&quot;comment&quot;&gt;// null&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 说明 Object.prototype.__proto__ = null&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript：prototype 和 __proto__ 的区别和联系</title>
    <link href="http://www.dengfuping.com/2017/04/29/javascript-prototype-and-__proto__/"/>
    <id>http://www.dengfuping.com/2017/04/29/javascript-prototype-and-__proto__/</id>
    <published>2017-04-29T13:42:40.000Z</published>
    <updated>2017-05-09T09:34:24.292Z</updated>
    
    <content type="html"><![CDATA[<p>（1）prototype 是函数( function ) 的一个属性, 它指向函数的原型。</p>
<p>（2）__proto__ 是对象的内部属性, 它指向构造器的原型, 对象依赖它进行原型链查询，instanceof 也是依赖它来判断是否继承关系。</p>
<p>由上, prototype 只有函数才有, 其他(非函数)对象不具有该属性. 而 __proto__ 是对象的内部属性, 任何对象都拥有该属性.</p>
<h2 id="prototype（显式原型）"><a href="#prototype（显式原型）" class="headerlink" title="prototype（显式原型）"></a>prototype（显式原型）</h2><p>Javascript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象，我们称之为 <code>原型对象</code> 。原型对象的所有属性和方法，都会被构造函数的实例继承。这意味着，我们可以把那些不变的属性和方法，直接定义在 <code>原型对象</code> 上。<a id="more"></a></p>
<p>注意：通过 Function.prototype.bind 方法构造出来的函数是个例外，它没有 prototype 属性。</p>
<p>作用：用来 <code>实现基于原型的继承</code> 与 <code>属性的共享</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, color</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.color = color;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Cat.prototype.type = <span class="string">"猫科动物"</span>;</div><div class="line">Cat.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">"吃老鼠"</span>)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="proto-（隐式原型）"><a href="#proto-（隐式原型）" class="headerlink" title="__proto__（隐式原型）"></a>__proto__（隐式原型）</h2><p>JavaScript 中任意对象都有一个内置属性 <code>__proto__</code> ，在 ES5 之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过 __proto__ 来访问。ES5中有了对于这个内置属性标准的 Get 方法即 getPrototypeOf() 。</p>
<p>注意：Object.prototype 这个对象是个例外，它的 __proto__ 值为 null 。</p>
<p>作用：构成原型链，同样用于 <code>实现基于原型的继承</code> 。举个例子，当我们访问 obj 这个对象中的 x 属性时，如果在 obj 中找不到，那么就会沿着 <code>__proto__</code> 依次查找。</p>
<h2 id="两者之间的关系"><a href="#两者之间的关系" class="headerlink" title="两者之间的关系"></a>两者之间的关系</h2><p>（1）对象有属性 <code>__proto__</code> ，指向该对象的构造函数的原型对象。<br>（2）构造函数除了有属性 <code>__proto__</code> ，还有属性 prototype ，prototype 指向该构造函数的原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, color</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.color = color;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat(<span class="string">"Jetty"</span>, <span class="string">"red"</span>);</div><div class="line"><span class="built_in">console</span>.log(cat.__proto__ == Cat.prototype);    <span class="comment">// true</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;（1）prototype 是函数( function ) 的一个属性, 它指向函数的原型。&lt;/p&gt;
&lt;p&gt;（2）__proto__ 是对象的内部属性, 它指向构造器的原型, 对象依赖它进行原型链查询，instanceof 也是依赖它来判断是否继承关系。&lt;/p&gt;
&lt;p&gt;由上, prototype 只有函数才有, 其他(非函数)对象不具有该属性. 而 __proto__ 是对象的内部属性, 任何对象都拥有该属性.&lt;/p&gt;
&lt;h2 id=&quot;prototype（显式原型）&quot;&gt;&lt;a href=&quot;#prototype（显式原型）&quot; class=&quot;headerlink&quot; title=&quot;prototype（显式原型）&quot;&gt;&lt;/a&gt;prototype（显式原型）&lt;/h2&gt;&lt;p&gt;Javascript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象，我们称之为 &lt;code&gt;原型对象&lt;/code&gt; 。原型对象的所有属性和方法，都会被构造函数的实例继承。这意味着，我们可以把那些不变的属性和方法，直接定义在 &lt;code&gt;原型对象&lt;/code&gt; 上。
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Fetch API 用法解析</title>
    <link href="http://www.dengfuping.com/2017/04/25/fetch-api/"/>
    <id>http://www.dengfuping.com/2017/04/25/fetch-api/</id>
    <published>2017-04-25T09:56:35.000Z</published>
    <updated>2017-04-25T10:24:29.315Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接：<a href="http://javascript.ruanyifeng.com/bom/ajax.html#toc27" target="_blank" rel="external">http://javascript.ruanyifeng.com/bom/ajax.html#toc27</a><a id="more"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考链接：&lt;a href=&quot;http://javascript.ruanyifeng.com/bom/ajax.html#toc27&quot;&gt;http://javascript.ruanyifeng.com/bom/ajax.html#toc27&lt;/a&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://www.dengfuping.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="fetch" scheme="http://www.dengfuping.com/tags/fetch/"/>
    
  </entry>
  
  <entry>
    <title>Http 状态码详解</title>
    <link href="http://www.dengfuping.com/2017/04/25/http-status-code/"/>
    <id>http://www.dengfuping.com/2017/04/25/http-status-code/</id>
    <published>2017-04-25T09:18:14.000Z</published>
    <updated>2017-04-25T10:23:26.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1xx（临时响应）"><a href="#1xx（临时响应）" class="headerlink" title="1xx（临时响应）"></a>1xx（临时响应）</h2><p>表示临时响应并需要请求者继续执行操作的状态代码。</p>
<p>100（继续）：请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 </p>
<p>101（切换协议）：请求者已要求服务器切换协议，服务器已确认并准备切换。<a id="more"></a></p>
<h2 id="2xx-（成功）"><a href="#2xx-（成功）" class="headerlink" title="2xx （成功）"></a>2xx （成功）</h2><p>表示成功处理了请求的状态代码。</p>
<p>200（成功）：服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</p>
<p>201（已创建）：请求成功并且服务器创建了新的资源。 </p>
<p>202（已接受）：服务器已接受请求，但尚未处理。 </p>
<p>203（非授权信息）：服务器已成功处理了请求，但返回的信息可能来自另一来源。</p>
<p>204（无内容）：服务器成功处理了请求，但没有返回任何内容。 </p>
<p>205（重置内容）：服务器成功处理了请求，但没有返回任何内容。 </p>
<p>206（部分内容）：服务器成功处理了部分 GET 请求。</p>
<h2 id="3xx-（重定向）"><a href="#3xx-（重定向）" class="headerlink" title="3xx （重定向）"></a>3xx （重定向）</h2><p>表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</p>
<p>300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</p>
<p>301（永久重定向/永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</p>
<p>302（临时移动）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p>
<p>303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</p>
<p>304（未修改）：自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</p>
<p>305（使用代理）：请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</p>
<p>307（临时重定向）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p>
<h2 id="4xx（客户端请求错误）"><a href="#4xx（客户端请求错误）" class="headerlink" title="4xx（客户端请求错误）"></a>4xx（客户端请求错误）</h2><p>这些状态代码表示请求可能出错，妨碍了服务器的处理。</p>
<p>400（错误请求）：服务器不理解请求的语法。</p>
<p>401（未授权）：请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</p>
<p>403（禁止）：服务器拒绝请求。</p>
<p>404（未找到）：服务器找不到请求的网页。</p>
<p>405（方法禁用）：禁用请求中指定的方法。</p>
<p>406（不接受）：无法使用请求的内容特性响应请求的网页。</p>
<p>407（需要代理授权）：此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</p>
<p>408（请求超时）：服务器等候请求时发生超时。</p>
<p>409（冲突）：服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</p>
<p>410（已删除）：如果请求的资源已永久删除，服务器就会返回此响应。</p>
<p>411（需要有效长度）：服务器不接受不含有效内容长度标头字段的请求。</p>
<p>412（未满足前提条件）：服务器未满足请求者在请求中设置的其中一个前提条件。</p>
<p>413（请求实体过大）：服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</p>
<p>414（请求的 URI 过长）：请求的 URI（通常为网址）过长，服务器无法处理。</p>
<p>415（不支持的媒体类型）：请求的格式不受请求页面的支持。</p>
<p>416（请求范围不符合要求）：如果页面无法提供请求的范围，则服务器会返回此状态代码。</p>
<p>417（未满足期望值）：服务器未满足”期望”请求标头字段的要求。</p>
<h2 id="5xx（服务器错误）"><a href="#5xx（服务器错误）" class="headerlink" title="5xx（服务器错误）"></a>5xx（服务器错误）</h2><p>这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p>
<p>500（服务器内部错误）：服务器遇到错误，无法完成请求。</p>
<p>501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</p>
<p>502（错误网关）：服务器作为网关或代理，从上游服务器收到无效响应。</p>
<p>503（服务不可用）：服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。</p>
<p>504（网关超时）：服务器作为网关或代理，但是没有及时从上游服务器收到请求。</p>
<p>505（HTTP 版本不受支持）：服务器不支持请求中所用的 HTTP 协议版本。</p>
<h2 id="4-个新的-HTTP-状态码"><a href="#4-个新的-HTTP-状态码" class="headerlink" title="4 个新的 HTTP 状态码"></a>4 个新的 HTTP 状态码</h2><p>RFC 6585 最近刚刚发布，该文档描述了 4 个新的 HTTP 状态码。新的状态码对于开发 REST 服务或者说是基于 HTTP 的服务非常有用，下面我们为你详细介绍这四个新的状态码以及是否应该使用。</p>
<h3 id="428-Precondition-Required-要求先决条件"><a href="#428-Precondition-Required-要求先决条件" class="headerlink" title="428: Precondition Required (要求先决条件)"></a>428: Precondition Required (要求先决条件)</h3><p>先决条件是客户端发送 HTTP 请求时，如果想要请求能成功必须满足一些预设的条件。</p>
<p>一个好的例子就是 If-None-Match 头，经常在 GET 请求中使用，如果指定了 If-None-Match ，那么客户端只在响应中的 ETag 改变后才会重新接收回应。</p>
<p>先决条件的另外一个例子就是 If-Match 头，这个一般用在 PUT 请求上用于指示只更新没被改变的资源，这在多个客户端使用 HTTP 服务时用来防止彼此间不会覆盖相同内容。</p>
<p>当服务器端使用 428 Precondition Required 状态码时，表示客户端必须发送上述的请求头才能执行请求，这个方法为服务器提供一种有效的方法来阻止 ‘lost update’ 问题。</p>
<h3 id="429-Too-Many-Requests-太多请求"><a href="#429-Too-Many-Requests-太多请求" class="headerlink" title="429: Too Many Requests (太多请求)"></a>429: Too Many Requests (太多请求)</h3><p>当你需要限制客户端请求某个服务数量时，该状态码就很有用，也就是请求速度限制。</p>
<p>在此之前，有一些类似的状态码，例如 ‘509 Bandwidth Limit Exceeded’. Twitter 使用 420 （这不是HTTP定义的状态码）</p>
<p>如果你希望限制客户端对服务的请求数，可使用 429 状态码，同时包含一个 Retry-After 响应头用于告诉客户端多长时间后可以再次请求服务。</p>
<h3 id="431-Request-Header-Fields-Too-Large-请求头字段太大"><a href="#431-Request-Header-Fields-Too-Large-请求头字段太大" class="headerlink" title="431: Request Header Fields Too Large (请求头字段太大)"></a>431: Request Header Fields Too Large (请求头字段太大)</h3><p>某些情况下，客户端发送 HTTP 请求头会变得很大，那么服务器可发送 431 Request Header Fields Too Large 来指明该问题。</p>
<p>我不太清楚为什么没有 430 状态码，而是直接从 429 跳到 431，我尝试搜索但没有结果。唯一的猜测是 430 Forbidden 跟 403 Forbidden 太像了，为了避免混淆才这么做的，天知道！</p>
<h3 id="511-Network-Authentication-Required-要求网络认证"><a href="#511-Network-Authentication-Required-要求网络认证" class="headerlink" title="511: Network Authentication Required (要求网络认证)"></a>511: Network Authentication Required (要求网络认证)</h3><p>对我来说这个状态码很有趣，如果你在开发一个 HTTP 服务器，你不一定需要处理该状态码，但如果你在编写 HTTP 客户端，那这个状态码就非常重要。</p>
<p>如果你频繁使用笔记本和智能手机，你可能会注意到大量的公用 WIFI 服务要求你必须接受一些协议或者必须登录后才能使用。</p>
<p>这是通过拦截 HTTP 流量，当用户试图访问网络返回一个重定向和登录，这很讨厌，但是实际情况就是这样的。</p>
<p>使用这些“拦截”客户端，会有一些讨厌的副作用。在 RFC 中有提到这两个的例子：</p>
<p>如果你在登录WIFI前访问某个网站，网络设备将会拦截首个请求，这些设备往往也有自己的网站图标 ‘favicon.ico’。登录后您会发现，有一段时间内你访问的网站图标一直是 WIFI 登录网站的图标。<br>如果客户端使用HTTP请求来查找文档（可能是 JSON），网络将会响应一个登录页，这样你的客户端就会解析错误并导致客户端运行异常，在现实中这种问题非常常见。<br>因此 511 状态码的提出就是为了解决这个问题。</p>
<p>如果你正在编写 HTTP 的客户端，你最好还是检查 511 状态码以确认是否需要认证后才能访问。</p>
<p>原文地址：<a href="http://www.cnblogs.com/aliang1992/p/6049681.html" target="_blank" rel="external">http://www.cnblogs.com/aliang1992/p/6049681.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1xx（临时响应）&quot;&gt;&lt;a href=&quot;#1xx（临时响应）&quot; class=&quot;headerlink&quot; title=&quot;1xx（临时响应）&quot;&gt;&lt;/a&gt;1xx（临时响应）&lt;/h2&gt;&lt;p&gt;表示临时响应并需要请求者继续执行操作的状态代码。&lt;/p&gt;
&lt;p&gt;100（继续）：请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 &lt;/p&gt;
&lt;p&gt;101（切换协议）：请求者已要求服务器切换协议，服务器已确认并准备切换。
    
    </summary>
    
      <category term="计算机网络" scheme="http://www.dengfuping.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="http" scheme="http://www.dengfuping.com/tags/http/"/>
    
      <category term="状态码" scheme="http://www.dengfuping.com/tags/%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Javascript：bubble and capture</title>
    <link href="http://www.dengfuping.com/2017/04/25/javascript-bubble-and-capture/"/>
    <id>http://www.dengfuping.com/2017/04/25/javascript-bubble-and-capture/</id>
    <published>2017-04-25T01:48:41.000Z</published>
    <updated>2017-05-02T10:12:01.843Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
