<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Deng | 不搭</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.dengfuping.com/"/>
  <updated>2017-05-10T00:13:15.872Z</updated>
  <id>http://www.dengfuping.com/</id>
  
  <author>
    <name>Deng | 不搭</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript：实现类继承的三种方法</title>
    <link href="http://www.dengfuping.com/2017/05/10/javascript-class-inheritence/"/>
    <id>http://www.dengfuping.com/2017/05/10/javascript-class-inheritence/</id>
    <published>2017-05-10T00:05:05.000Z</published>
    <updated>2017-05-10T00:13:15.872Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、通过扩展-Object-实现"><a href="#一、通过扩展-Object-实现" class="headerlink" title="一、通过扩展 Object 实现"></a>一、通过扩展 Object 实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义一个父类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">add</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.add = add;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 定义一个子类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 定义一个全局都可以用的继承方法</span></div><div class="line"><span class="built_in">Object</span>.prototype.extend = <span class="function"><span class="keyword">function</span>(<span class="params">ParentObj</span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> ParentObj)&#123;</div><div class="line">        <span class="keyword">this</span>[i] = ParentObj[i]</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">Child.extend(Parent(<span class="string">'China'</span>)); <span class="comment">// 使用我们的方法进行继承</span></div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Child(<span class="string">'lemon'</span>)   <span class="comment">// 实例化对象（初始化数据）</span></div><div class="line"><span class="built_in">console</span>.log(obj.add);  <span class="comment">// 此时我们就可以调用父类中的方法或属性了，输出结果：China</span></div></pre></td></tr></table></figure>
<p>这种方法的原理是通过 <code>浅拷贝</code> 实现的，实际上是将父类的所以属性复制到子类当中，从而使得子类可以访问父类的属性。</p>
<p>##</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>##</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、通过扩展-Object-实现&quot;&gt;&lt;a href=&quot;#一、通过扩展-Object-实现&quot; class=&quot;headerlink&quot; title=&quot;一、通过扩展 Object 实现&quot;&gt;&lt;/a&gt;一、通过扩展 Object 实现&lt;/h2&gt;&lt;figure class=&quot;hi
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript：继承方式</title>
    <link href="http://www.dengfuping.com/2017/05/09/javascript-inheritance/"/>
    <id>http://www.dengfuping.com/2017/05/09/javascript-inheritance/</id>
    <published>2017-05-09T09:08:47.000Z</published>
    <updated>2017-05-09T09:42:11.474Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="external">阮一峰：JavaScript 构造函数的继承</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html" target="_blank" rel="external">阮一峰：非构造函数的继承</a></p>
<p><a href="http://dudodo.cc/2017/04/11/%E7%90%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/" target="_blank" rel="external">理解 JS 中的继承</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/24964910?refer=muyichuanqi" target="_blank" rel="external">js原型链继承，借用构造函数继承,组合继承，寄生式继承，寄生组合继承</a><br><a id="more"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html&quot;&gt;阮一峰：JavaScript 构造函数的继承&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html&quot;&gt;阮一峰：非构造函数的继承&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dudodo.cc/2017/04/11/%E7%90%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/&quot;&gt;理解 JS 中的继承&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24964910?refer=muyichuanqi&quot;&gt;js原型链继承，借用构造函数继承,组合继承，寄生式继承，寄生组合继承&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript：闭包</title>
    <link href="http://www.dengfuping.com/2017/05/06/javascript-closure/"/>
    <id>http://www.dengfuping.com/2017/05/06/javascript-closure/</id>
    <published>2017-05-06T10:32:37.000Z</published>
    <updated>2017-05-09T09:19:19.346Z</updated>
    
    <content type="html"><![CDATA[<p>一、什么是闭包？闭包有什么好处？使用闭包要注意什么？</p>
<p>闭包：函数嵌套函数，内部函数可以引用外部函数的参数和变量，变量和参数不会被垃圾回收机制所回收</p>
<p>好处：<br>（1）希望一个变量长期驻扎在内存之中</p>
<p>（2）避免全局变量的污染</p>
<p>（3）私有成员的存在</p>
<p>注意：可能会造成内存泄漏<br><a id="more"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、什么是闭包？闭包有什么好处？使用闭包要注意什么？&lt;/p&gt;
&lt;p&gt;闭包：函数嵌套函数，内部函数可以引用外部函数的参数和变量，变量和参数不会被垃圾回收机制所回收&lt;/p&gt;
&lt;p&gt;好处：&lt;br&gt;（1）希望一个变量长期驻扎在内存之中&lt;/p&gt;
&lt;p&gt;（2）避免全局变量的污染&lt;/p&gt;
&lt;p&gt;（3）私有成员的存在&lt;/p&gt;
&lt;p&gt;注意：可能会造成内存泄漏&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CSS（四）：垂直居中常用方法</title>
    <link href="http://www.dengfuping.com/2017/05/06/css-vertical-align/"/>
    <id>http://www.dengfuping.com/2017/05/06/css-vertical-align/</id>
    <published>2017-05-06T10:11:45.000Z</published>
    <updated>2017-05-06T10:25:59.697Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单行文本"><a href="#单行文本" class="headerlink" title="单行文本"></a>单行文本</h2><p>若元素是单行文本, 则可设置 line-height 等于父元素高度</p>
<h2 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h2><p>（1）使用 <code>flex</code> 布局，给 <code>父元素</code> 设置如下属性：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.parent</span> &#123;</div><div class="line">    <span class="attribute">display</span>: flex;</div><div class="line">    <span class="attribute">align-items</span>: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单行文本&quot;&gt;&lt;a href=&quot;#单行文本&quot; class=&quot;headerlink&quot; title=&quot;单行文本&quot;&gt;&lt;/a&gt;单行文本&lt;/h2&gt;&lt;p&gt;若元素是单行文本, 则可设置 line-height 等于父元素高度&lt;/p&gt;
&lt;h2 id=&quot;块级元素&quot;&gt;&lt;a href=&quot;
    
    </summary>
    
      <category term="CSS" scheme="http://www.dengfuping.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://www.dengfuping.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS（三）：水平居中常用方法</title>
    <link href="http://www.dengfuping.com/2017/05/06/css-horizontal-align/"/>
    <id>http://www.dengfuping.com/2017/05/06/css-horizontal-align/</id>
    <published>2017-05-06T09:49:42.000Z</published>
    <updated>2017-05-06T10:29:10.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h2><p>给其 <code>父元素</code> 设置 <code>text-align: center</code> ，即可实现行内元素水平居中。</p>
<h2 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h2><p>（1）给 <code>该元素</code> 设置 <code>margin: 0 auto</code> 即可实现块级元素水平居中。适用于 <code>定宽块状元素</code> 。</p>
<p>（2）使用 <code>flex</code> 布局，给 <code>父元素</code> 设置如下属性：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.parent</span> &#123;</div><div class="line">    <span class="attribute">display</span>: flex;</div><div class="line">    <span class="attribute">justify-content</span>: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;行内元素&quot;&gt;&lt;a href=&quot;#行内元素&quot; class=&quot;headerlink&quot; title=&quot;行内元素&quot;&gt;&lt;/a&gt;行内元素&lt;/h2&gt;&lt;p&gt;给其 &lt;code&gt;父元素&lt;/code&gt; 设置 &lt;code&gt;text-align: center&lt;/code&gt; ，即可实现行内
    
    </summary>
    
      <category term="CSS" scheme="http://www.dengfuping.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://www.dengfuping.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS（二）：BFC 深入理解</title>
    <link href="http://www.dengfuping.com/2017/05/04/css-BFC/"/>
    <id>http://www.dengfuping.com/2017/05/04/css-BFC/</id>
    <published>2017-05-04T08:54:58.000Z</published>
    <updated>2017-05-06T09:54:21.246Z</updated>
    
    <content type="html"><![CDATA[<p>请参考文章：<a href="https://juejin.im/post/5909db2fda2f60005d2093db" target="_blank" rel="external">布局概念之关于CSS-BFC深入理解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;请参考文章：&lt;a href=&quot;https://juejin.im/post/5909db2fda2f60005d2093db&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;布局概念之关于CSS-BFC深入理解&lt;/a&gt;&lt;/p&gt;

    
    </summary>
    
      <category term="CSS" scheme="http://www.dengfuping.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://www.dengfuping.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Javascript：null 和 undefined 用法解析</title>
    <link href="http://www.dengfuping.com/2017/05/02/javascript-null-and-undefined/"/>
    <id>http://www.dengfuping.com/2017/05/02/javascript-null-and-undefined/</id>
    <published>2017-05-02T02:10:02.000Z</published>
    <updated>2017-05-02T10:15:37.173Z</updated>
    
    <content type="html"><![CDATA[<p>目前，<code>null</code> 和 <code>undefined</code> 基本是同义的，只有一些细微的差别。</p>
<h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><p>null表示”没有对象”，即该处不应该有值。典型用法是：</p>
<p>（1） 作为函数的参数，表示该函数的参数不是对象。</p>
<p>（2） 作为对象原型链的终点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype);   <span class="comment">// null</span></div><div class="line"><span class="comment">// 说明 Object.prototype.__proto__ = null</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h2><p>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：</p>
<p>（1）变量被声明了，但没有赋值时，就等于undefined。</p>
<p>（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。</p>
<p>（3）对象没有赋值的属性，该属性的值为undefined。</p>
<p>（4）函数没有返回值时，默认返回undefined。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i;</div><div class="line">i <span class="comment">// undefined</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;<span class="built_in">console</span>.log(x)&#125;</div><div class="line">f() <span class="comment">// undefined</span></div><div class="line"></div><div class="line"><span class="keyword">var</span>  o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">o.p <span class="comment">// undefined</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> x = f();</div><div class="line">x <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前，&lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 基本是同义的，只有一些细微的差别。&lt;/p&gt;
&lt;h2 id=&quot;null&quot;&gt;&lt;a href=&quot;#null&quot; class=&quot;headerlink&quot; title=&quot;null&quot;&gt;&lt;/a&gt;null&lt;/h2&gt;&lt;p&gt;null表示”没有对象”，即该处不应该有值。典型用法是：&lt;/p&gt;
&lt;p&gt;（1） 作为函数的参数，表示该函数的参数不是对象。&lt;/p&gt;
&lt;p&gt;（2） 作为对象原型链的终点。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.getPrototypeOf(&lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.prototype);   &lt;span class=&quot;comment&quot;&gt;// null&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 说明 Object.prototype.__proto__ = null&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript：prototype 和 __proto__ 的区别和联系</title>
    <link href="http://www.dengfuping.com/2017/04/29/javascript-prototype-and-__proto__/"/>
    <id>http://www.dengfuping.com/2017/04/29/javascript-prototype-and-__proto__/</id>
    <published>2017-04-29T13:42:40.000Z</published>
    <updated>2017-05-09T09:34:24.292Z</updated>
    
    <content type="html"><![CDATA[<p>（1）prototype 是函数( function ) 的一个属性, 它指向函数的原型。</p>
<p>（2）__proto__ 是对象的内部属性, 它指向构造器的原型, 对象依赖它进行原型链查询，instanceof 也是依赖它来判断是否继承关系。</p>
<p>由上, prototype 只有函数才有, 其他(非函数)对象不具有该属性. 而 __proto__ 是对象的内部属性, 任何对象都拥有该属性.</p>
<h2 id="prototype（显式原型）"><a href="#prototype（显式原型）" class="headerlink" title="prototype（显式原型）"></a>prototype（显式原型）</h2><p>Javascript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象，我们称之为 <code>原型对象</code> 。原型对象的所有属性和方法，都会被构造函数的实例继承。这意味着，我们可以把那些不变的属性和方法，直接定义在 <code>原型对象</code> 上。<a id="more"></a></p>
<p>注意：通过 Function.prototype.bind 方法构造出来的函数是个例外，它没有 prototype 属性。</p>
<p>作用：用来 <code>实现基于原型的继承</code> 与 <code>属性的共享</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, color</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.color = color;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Cat.prototype.type = <span class="string">"猫科动物"</span>;</div><div class="line">Cat.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">"吃老鼠"</span>)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="proto-（隐式原型）"><a href="#proto-（隐式原型）" class="headerlink" title="__proto__（隐式原型）"></a>__proto__（隐式原型）</h2><p>JavaScript 中任意对象都有一个内置属性 <code>__proto__</code> ，在 ES5 之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过 __proto__ 来访问。ES5中有了对于这个内置属性标准的 Get 方法即 getPrototypeOf() 。</p>
<p>注意：Object.prototype 这个对象是个例外，它的 __proto__ 值为 null 。</p>
<p>作用：构成原型链，同样用于 <code>实现基于原型的继承</code> 。举个例子，当我们访问 obj 这个对象中的 x 属性时，如果在 obj 中找不到，那么就会沿着 <code>__proto__</code> 依次查找。</p>
<h2 id="两者之间的关系"><a href="#两者之间的关系" class="headerlink" title="两者之间的关系"></a>两者之间的关系</h2><p>（1）对象有属性 <code>__proto__</code> ，指向该对象的构造函数的原型对象。<br>（2）构造函数除了有属性 <code>__proto__</code> ，还有属性 prototype ，prototype 指向该构造函数的原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, color</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.color = color;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat(<span class="string">"Jetty"</span>, <span class="string">"red"</span>);</div><div class="line"><span class="built_in">console</span>.log(cat.__proto__ == Cat.prototype);    <span class="comment">// true</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;（1）prototype 是函数( function ) 的一个属性, 它指向函数的原型。&lt;/p&gt;
&lt;p&gt;（2）__proto__ 是对象的内部属性, 它指向构造器的原型, 对象依赖它进行原型链查询，instanceof 也是依赖它来判断是否继承关系。&lt;/p&gt;
&lt;p&gt;由上, prototype 只有函数才有, 其他(非函数)对象不具有该属性. 而 __proto__ 是对象的内部属性, 任何对象都拥有该属性.&lt;/p&gt;
&lt;h2 id=&quot;prototype（显式原型）&quot;&gt;&lt;a href=&quot;#prototype（显式原型）&quot; class=&quot;headerlink&quot; title=&quot;prototype（显式原型）&quot;&gt;&lt;/a&gt;prototype（显式原型）&lt;/h2&gt;&lt;p&gt;Javascript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象，我们称之为 &lt;code&gt;原型对象&lt;/code&gt; 。原型对象的所有属性和方法，都会被构造函数的实例继承。这意味着，我们可以把那些不变的属性和方法，直接定义在 &lt;code&gt;原型对象&lt;/code&gt; 上。
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Fetch API 用法解析</title>
    <link href="http://www.dengfuping.com/2017/04/25/fetch-api/"/>
    <id>http://www.dengfuping.com/2017/04/25/fetch-api/</id>
    <published>2017-04-25T09:56:35.000Z</published>
    <updated>2017-04-25T10:24:29.315Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接：<a href="http://javascript.ruanyifeng.com/bom/ajax.html#toc27" target="_blank" rel="external">http://javascript.ruanyifeng.com/bom/ajax.html#toc27</a><a id="more"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考链接：&lt;a href=&quot;http://javascript.ruanyifeng.com/bom/ajax.html#toc27&quot;&gt;http://javascript.ruanyifeng.com/bom/ajax.html#toc27&lt;/a&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://www.dengfuping.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="fetch" scheme="http://www.dengfuping.com/tags/fetch/"/>
    
  </entry>
  
  <entry>
    <title>Http 状态码详解</title>
    <link href="http://www.dengfuping.com/2017/04/25/http-status-code/"/>
    <id>http://www.dengfuping.com/2017/04/25/http-status-code/</id>
    <published>2017-04-25T09:18:14.000Z</published>
    <updated>2017-04-25T10:23:26.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1xx（临时响应）"><a href="#1xx（临时响应）" class="headerlink" title="1xx（临时响应）"></a>1xx（临时响应）</h2><p>表示临时响应并需要请求者继续执行操作的状态代码。</p>
<p>100（继续）：请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 </p>
<p>101（切换协议）：请求者已要求服务器切换协议，服务器已确认并准备切换。<a id="more"></a></p>
<h2 id="2xx-（成功）"><a href="#2xx-（成功）" class="headerlink" title="2xx （成功）"></a>2xx （成功）</h2><p>表示成功处理了请求的状态代码。</p>
<p>200（成功）：服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</p>
<p>201（已创建）：请求成功并且服务器创建了新的资源。 </p>
<p>202（已接受）：服务器已接受请求，但尚未处理。 </p>
<p>203（非授权信息）：服务器已成功处理了请求，但返回的信息可能来自另一来源。</p>
<p>204（无内容）：服务器成功处理了请求，但没有返回任何内容。 </p>
<p>205（重置内容）：服务器成功处理了请求，但没有返回任何内容。 </p>
<p>206（部分内容）：服务器成功处理了部分 GET 请求。</p>
<h2 id="3xx-（重定向）"><a href="#3xx-（重定向）" class="headerlink" title="3xx （重定向）"></a>3xx （重定向）</h2><p>表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</p>
<p>300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</p>
<p>301（永久重定向/永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</p>
<p>302（临时移动）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p>
<p>303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</p>
<p>304（未修改）：自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</p>
<p>305（使用代理）：请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</p>
<p>307（临时重定向）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p>
<h2 id="4xx（客户端请求错误）"><a href="#4xx（客户端请求错误）" class="headerlink" title="4xx（客户端请求错误）"></a>4xx（客户端请求错误）</h2><p>这些状态代码表示请求可能出错，妨碍了服务器的处理。</p>
<p>400（错误请求）：服务器不理解请求的语法。</p>
<p>401（未授权）：请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</p>
<p>403（禁止）：服务器拒绝请求。</p>
<p>404（未找到）：服务器找不到请求的网页。</p>
<p>405（方法禁用）：禁用请求中指定的方法。</p>
<p>406（不接受）：无法使用请求的内容特性响应请求的网页。</p>
<p>407（需要代理授权）：此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</p>
<p>408（请求超时）：服务器等候请求时发生超时。</p>
<p>409（冲突）：服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</p>
<p>410（已删除）：如果请求的资源已永久删除，服务器就会返回此响应。</p>
<p>411（需要有效长度）：服务器不接受不含有效内容长度标头字段的请求。</p>
<p>412（未满足前提条件）：服务器未满足请求者在请求中设置的其中一个前提条件。</p>
<p>413（请求实体过大）：服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</p>
<p>414（请求的 URI 过长）：请求的 URI（通常为网址）过长，服务器无法处理。</p>
<p>415（不支持的媒体类型）：请求的格式不受请求页面的支持。</p>
<p>416（请求范围不符合要求）：如果页面无法提供请求的范围，则服务器会返回此状态代码。</p>
<p>417（未满足期望值）：服务器未满足”期望”请求标头字段的要求。</p>
<h2 id="5xx（服务器错误）"><a href="#5xx（服务器错误）" class="headerlink" title="5xx（服务器错误）"></a>5xx（服务器错误）</h2><p>这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p>
<p>500（服务器内部错误）：服务器遇到错误，无法完成请求。</p>
<p>501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</p>
<p>502（错误网关）：服务器作为网关或代理，从上游服务器收到无效响应。</p>
<p>503（服务不可用）：服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。</p>
<p>504（网关超时）：服务器作为网关或代理，但是没有及时从上游服务器收到请求。</p>
<p>505（HTTP 版本不受支持）：服务器不支持请求中所用的 HTTP 协议版本。</p>
<h2 id="4-个新的-HTTP-状态码"><a href="#4-个新的-HTTP-状态码" class="headerlink" title="4 个新的 HTTP 状态码"></a>4 个新的 HTTP 状态码</h2><p>RFC 6585 最近刚刚发布，该文档描述了 4 个新的 HTTP 状态码。新的状态码对于开发 REST 服务或者说是基于 HTTP 的服务非常有用，下面我们为你详细介绍这四个新的状态码以及是否应该使用。</p>
<h3 id="428-Precondition-Required-要求先决条件"><a href="#428-Precondition-Required-要求先决条件" class="headerlink" title="428: Precondition Required (要求先决条件)"></a>428: Precondition Required (要求先决条件)</h3><p>先决条件是客户端发送 HTTP 请求时，如果想要请求能成功必须满足一些预设的条件。</p>
<p>一个好的例子就是 If-None-Match 头，经常在 GET 请求中使用，如果指定了 If-None-Match ，那么客户端只在响应中的 ETag 改变后才会重新接收回应。</p>
<p>先决条件的另外一个例子就是 If-Match 头，这个一般用在 PUT 请求上用于指示只更新没被改变的资源，这在多个客户端使用 HTTP 服务时用来防止彼此间不会覆盖相同内容。</p>
<p>当服务器端使用 428 Precondition Required 状态码时，表示客户端必须发送上述的请求头才能执行请求，这个方法为服务器提供一种有效的方法来阻止 ‘lost update’ 问题。</p>
<h3 id="429-Too-Many-Requests-太多请求"><a href="#429-Too-Many-Requests-太多请求" class="headerlink" title="429: Too Many Requests (太多请求)"></a>429: Too Many Requests (太多请求)</h3><p>当你需要限制客户端请求某个服务数量时，该状态码就很有用，也就是请求速度限制。</p>
<p>在此之前，有一些类似的状态码，例如 ‘509 Bandwidth Limit Exceeded’. Twitter 使用 420 （这不是HTTP定义的状态码）</p>
<p>如果你希望限制客户端对服务的请求数，可使用 429 状态码，同时包含一个 Retry-After 响应头用于告诉客户端多长时间后可以再次请求服务。</p>
<h3 id="431-Request-Header-Fields-Too-Large-请求头字段太大"><a href="#431-Request-Header-Fields-Too-Large-请求头字段太大" class="headerlink" title="431: Request Header Fields Too Large (请求头字段太大)"></a>431: Request Header Fields Too Large (请求头字段太大)</h3><p>某些情况下，客户端发送 HTTP 请求头会变得很大，那么服务器可发送 431 Request Header Fields Too Large 来指明该问题。</p>
<p>我不太清楚为什么没有 430 状态码，而是直接从 429 跳到 431，我尝试搜索但没有结果。唯一的猜测是 430 Forbidden 跟 403 Forbidden 太像了，为了避免混淆才这么做的，天知道！</p>
<h3 id="511-Network-Authentication-Required-要求网络认证"><a href="#511-Network-Authentication-Required-要求网络认证" class="headerlink" title="511: Network Authentication Required (要求网络认证)"></a>511: Network Authentication Required (要求网络认证)</h3><p>对我来说这个状态码很有趣，如果你在开发一个 HTTP 服务器，你不一定需要处理该状态码，但如果你在编写 HTTP 客户端，那这个状态码就非常重要。</p>
<p>如果你频繁使用笔记本和智能手机，你可能会注意到大量的公用 WIFI 服务要求你必须接受一些协议或者必须登录后才能使用。</p>
<p>这是通过拦截 HTTP 流量，当用户试图访问网络返回一个重定向和登录，这很讨厌，但是实际情况就是这样的。</p>
<p>使用这些“拦截”客户端，会有一些讨厌的副作用。在 RFC 中有提到这两个的例子：</p>
<p>如果你在登录WIFI前访问某个网站，网络设备将会拦截首个请求，这些设备往往也有自己的网站图标 ‘favicon.ico’。登录后您会发现，有一段时间内你访问的网站图标一直是 WIFI 登录网站的图标。<br>如果客户端使用HTTP请求来查找文档（可能是 JSON），网络将会响应一个登录页，这样你的客户端就会解析错误并导致客户端运行异常，在现实中这种问题非常常见。<br>因此 511 状态码的提出就是为了解决这个问题。</p>
<p>如果你正在编写 HTTP 的客户端，你最好还是检查 511 状态码以确认是否需要认证后才能访问。</p>
<p>原文地址：<a href="http://www.cnblogs.com/aliang1992/p/6049681.html" target="_blank" rel="external">http://www.cnblogs.com/aliang1992/p/6049681.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1xx（临时响应）&quot;&gt;&lt;a href=&quot;#1xx（临时响应）&quot; class=&quot;headerlink&quot; title=&quot;1xx（临时响应）&quot;&gt;&lt;/a&gt;1xx（临时响应）&lt;/h2&gt;&lt;p&gt;表示临时响应并需要请求者继续执行操作的状态代码。&lt;/p&gt;
&lt;p&gt;100（继续）：请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 &lt;/p&gt;
&lt;p&gt;101（切换协议）：请求者已要求服务器切换协议，服务器已确认并准备切换。
    
    </summary>
    
      <category term="计算机网络" scheme="http://www.dengfuping.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="http" scheme="http://www.dengfuping.com/tags/http/"/>
    
      <category term="状态码" scheme="http://www.dengfuping.com/tags/%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Javascript：bubble and capture</title>
    <link href="http://www.dengfuping.com/2017/04/25/javascript-bubble-and-capture/"/>
    <id>http://www.dengfuping.com/2017/04/25/javascript-bubble-and-capture/</id>
    <published>2017-04-25T01:48:41.000Z</published>
    <updated>2017-05-02T10:12:01.843Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jQuery 事件绑定函数解析：bind, on, delegate</title>
    <link href="http://www.dengfuping.com/2017/04/24/javascript-jquery-bind-on-delegate/"/>
    <id>http://www.dengfuping.com/2017/04/24/javascript-jquery-bind-on-delegate/</id>
    <published>2017-04-24T03:05:16.000Z</published>
    <updated>2017-05-02T10:12:11.508Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章主要是对 jQuery 中的四种事件绑定函数 bind, on, delegate, live 进行一个分析和比较。</p>
<p>先准备一个html页面再对其中的元素进行事件绑定：<a id="more"></a></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>bind-on-delegate-live<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"button"</span>&gt;</span>添加新的p元素<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>第一个p元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>第二个p元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>第三个p元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>第四个p元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>第五个p元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    $(<span class="string">"#button"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        $(<span class="string">"div"</span>).append(<span class="string">"&lt;p&gt;这是一个新的p元素&lt;/p&gt;"</span>)</div><div class="line">    &#125;);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>一个简单的页面，放置了一个div，div里面若干个p元素和一个按钮，点击按钮可以追加p元素。我们下面将对页面上的p元素绑定click事件。</p>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bind</span></div><div class="line">$(<span class="string">"div p"</span>).bind(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert($(<span class="keyword">this</span>).text());</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// bind 的简写形式</span></div><div class="line">$(<span class="string">"div p"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert($(<span class="keyword">this</span>).text());</div></pre></td></tr></table></figure>
<ol>
<li>这里用了隐式迭代的方法，如果匹配到的元素特别多的时候，比如如果我在 div 里放了 50 个 p 元素，就得执行绑定 50 次。对于大量元素来说，影响到了性能。但是如果是 id 选择器，因为id唯一，用 bind() 方法就很快捷了。</li>
<li>对于尚未存在的元素，无法绑定。点击页面上的按钮，将动态添加一个p元素，点击这个 p 元素，会发现没有动作响应。</li>
</ol>
<p>使用 delegate 可以解决以上这两个问题。</p>
<h2 id="delegate"><a href="#delegate" class="headerlink" title="delegate"></a>delegate</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// delegate</span></div><div class="line">$(<span class="string">"div"</span>).delegate(<span class="string">"p"</span>, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert($(<span class="keyword">this</span>).text());</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ol>
<li><p>这种方式采用了事件委托的概念。不是直接为 p 元素绑定事件，而是为其父元素（或祖先元素也可）绑定事件，当在 div 内任意元素上点击时，事件会一层层从 event target向上冒泡，直至到达你为其绑定事件的元素，如此例中的div元素。冒泡的过程中，如果事件的 currentTarget 与选择器匹配时，就会执行代码。</p>
</li>
<li><p>这样就解决了用 bind() 方法的上面两个问题，不用再一个个地去为 p 元素绑定事件，也可以为动态添加进来的 p 元素绑定。甚至，如果你将事件绑定到 document 上，都不用等 document 准备好就可执行绑定。</p>
</li>
<li><p>这样，绑定是容易了，但是调用的时候也可能出现问题。如果事件目标在 DOM 树中很深的位置，这样一层层冒泡上来查找与选择器匹配的元素，又影响到性能了。</p>
</li>
</ol>
<h2 id="on"><a href="#on" class="headerlink" title="on"></a>on</h2><p>on() 其实是将以前的绑定事件方法作了统一，查看 jQuery 无压缩的源码（版本 1.11.3），可以发现无论 bind() 还是 delegate() 其实都是通过 on() 方法实现的，只是参数不同罢了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">bind: <span class="function"><span class="keyword">function</span>(<span class="params"> types, data, fn </span>) </span>&#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.on( types, <span class="literal">null</span>, data, fn );</div><div class="line">&#125;,</div><div class="line"><span class="attr">unbind</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> types, fn </span>) </span>&#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.off( types, <span class="literal">null</span>, fn );</div><div class="line">&#125;,</div><div class="line"><span class="attr">delegate</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> selector, types, data, fn </span>) </span>&#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.on( types, selector, data, fn );</div><div class="line">&#125;</div><div class="line">undelegate: <span class="function"><span class="keyword">function</span>(<span class="params"> selector, types, fn </span>) </span>&#123;</div><div class="line"> <span class="comment">// ( namespace ) or ( selector, types [, fn] )</span></div><div class="line">     <span class="keyword">return</span> <span class="built_in">arguments</span>.length === <span class="number">1</span> ? <span class="keyword">this</span>.off( selector, <span class="string">"**"</span> ) : <span class="keyword">this</span>.off( types, selector || <span class="string">"**"</span>, fn );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// on</span></div><div class="line">$(<span class="string">"div"</span>).on(<span class="string">"click"</span>, <span class="string">"p"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert($(<span class="keyword">this</span>).text());</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="移除事件"><a href="#移除事件" class="headerlink" title="移除事件"></a>移除事件</h2><p>对应于 bind()、delegate() 和 on() 绑定方法，其移除事件的方法分别为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$( <span class="string">"div p"</span> ).unbind( <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);</div><div class="line">$( <span class="string">"div"</span> ).undelegate( <span class="string">"p"</span>, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);</div><div class="line">$( <span class="string">"div"</span> ).off( <span class="string">"click"</span>, <span class="string">"p"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>选择器匹配到的元素比较多时，不要用 bind() 迭代绑定。</li>
<li>用 id 选择器时，可以用 bind()。</li>
<li>需要给动态添加的元素绑定时，用 delegate() 或者 on()。</li>
<li>用 delegate() 和 on() 方法，DOM 树不要太深。</li>
<li>尽量使用 on()。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章主要是对 jQuery 中的四种事件绑定函数 bind, on, delegate, live 进行一个分析和比较。&lt;/p&gt;
&lt;p&gt;先准备一个html页面再对其中的元素进行事件绑定：
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript：事件绑定的三种方法</title>
    <link href="http://www.dengfuping.com/2017/04/24/javascript-three-ways-of-event-binding/"/>
    <id>http://www.dengfuping.com/2017/04/24/javascript-three-ways-of-event-binding/</id>
    <published>2017-04-24T02:43:36.000Z</published>
    <updated>2017-05-02T10:12:52.814Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"button1"</span> <span class="attr">onclick</span>=<span class="string">"click1()"</span>&gt;</span>按钮1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">click1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="string">"你点击了按钮1"</span>);</div><div class="line">    &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"button2"</span>&gt;</span>按钮2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"button2"</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="string">"你点击了按钮2"</span>);</div><div class="line">    &#125;;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"button3"</span>&gt;</span>按钮3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">click3</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="string">"你点击了按钮3"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"button3"</span>).addEventListener(<span class="string">"click"</span>, click3, <span class="literal">false</span>);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>使用 <code>addEventlistener()</code> 可以多次绑定同一个事件，且都会执行。如果使用方法一绑定两个 <code>onclick</code> 事件，则只会执行第一个；而使用方法二绑定的只会执行最后一个事件。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;方法一&quot;&gt;&lt;a href=&quot;#方法一&quot; class=&quot;headerlink&quot; title=&quot;方法一&quot;&gt;&lt;/a&gt;方法一&lt;/h2&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;button&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;button1&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;onclick&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;click1()&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;按钮1&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;javascript&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;click1&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        alert(&lt;span class=&quot;string&quot;&gt;&quot;你点击了按钮1&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript：正则表达式</title>
    <link href="http://www.dengfuping.com/2017/04/23/javascript-regular-expression/"/>
    <id>http://www.dengfuping.com/2017/04/23/javascript-regular-expression/</id>
    <published>2017-04-23T14:33:29.000Z</published>
    <updated>2017-05-02T10:12:44.442Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://i1.piimg.com/567571/aa45ebe58e9a229f.jpg" alt=""><br><a id="more"></a></p>
<ol>
<li>^ 匹配一个输入或一行的开头，<code>/^a/</code> 匹配”an A”，而不匹配”An a” </li>
<li>$ 匹配一个输入或一行的结尾，<code>/a$/</code> 匹配”An a”，而不匹配”an A” </li>
<li><ul>
<li>匹配前面元字符0次或多次，<code>/ba*/</code> 将匹配b,ba,baa,baaa </li>
</ul>
</li>
<li><ul>
<li>匹配前面元字符1次或多次，<code>/ba*/</code> 将匹配ba,baa,baaa </li>
</ul>
</li>
<li>? 匹配前面元字符0次或1次，<code>/ba*/</code> 将匹配b,ba </li>
<li>(x) 匹配 x 保存 x 在名为 $1…$9 的变量中 </li>
<li>x|y 匹配 x 或 y </li>
<li>{n} 精确匹配 n 次 </li>
<li>{n,} 匹配 n 次以上 </li>
<li>{n, m} 匹配 n-m 次 </li>
<li><code>[xyz]</code> 字符集(character set)，匹配这个集合中的任一一个字符(或元字符) </li>
<li><code>[^xyz]</code> 不匹配这个集合中的任何一个字符 </li>
<li>[\b] 匹配一个退格符 </li>
<li>\b 匹配一个单词的边界 </li>
<li>\B 匹配一个单词的非边界 </li>
<li>\cX 这儿，X 是一个控制符，<code>/\cM/</code> 匹配 Ctrl-M </li>
<li>\d 匹配一个字数字符，<code>/\d/ = /[0-9]/</code> </li>
<li>\D 匹配一个非字数字符，<code>/\D/ = /[^0-9]/</code> </li>
<li>\n 匹配一个换行符 </li>
<li>\r 匹配一个回车符 </li>
<li>\s 匹配一个空白字符，包括 \n, \r, \f, \t, \v 等 </li>
<li>\S 匹配一个非空白字符，等于 <code>/[^\n\f\r\t\v]/</code> </li>
<li>\t 匹配一个制表符 </li>
<li>\v 匹配一个重直制表符 </li>
<li>\w 匹配一个可以组成单词的字符(alphanumeric，这是我的意译，含数字)，包括下划线，如 <code>[\w]</code> 匹配 “$5.98” 中的 5，等于 <code>[a-zA-Z0-9]</code> </li>
<li>\W 匹配一个不可以组成单词的字符，如 [\W] 匹配 “$5.98” 中的 $，等于 <code>[^a-zA-Z0-9]</code></li>
<li>.（点符号）：除了换行符之外的任意字符,等价于 <code>[^\n]</code>（在2017年阿里巴巴春季实习生招聘的前端模拟笔试考察过这一知识点） </li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://i1.piimg.com/567571/aa45ebe58e9a229f.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CSS（一）：文本溢出显示省略号</title>
    <link href="http://www.dengfuping.com/2017/04/23/css-text-overflow-ellipsis/"/>
    <id>http://www.dengfuping.com/2017/04/23/css-text-overflow-ellipsis/</id>
    <published>2017-04-23T12:46:34.000Z</published>
    <updated>2017-05-06T09:54:06.156Z</updated>
    
    <content type="html"><![CDATA[<p>这是在网易技术二面的时候面试官问到的一个问题，当时没有答出来，今天在这里作一次解决该问题方法的总结。</p>
<h2 id="单行文本溢出"><a href="#单行文本溢出" class="headerlink" title="单行文本溢出"></a>单行文本溢出</h2><p>可以使用 <code>text-overflow: ellipsis</code> 属性来实现单行文本溢出显示省略号，当然还需要加宽度 <code>width</code> 属性来兼容部分浏览器。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.single-text</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">490px</span>;</div><div class="line">    <span class="attribute">overflow</span>: hidden;</div><div class="line">    <span class="attribute">text-overflow</span>: ellipsis;</div><div class="line">    <span class="attribute">white-space</span>: nowrap;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<ol>
<li>overflow: hidden; 溢出元素内容区的内容不可见的。</li>
<li>white-space: nowrap; 文本不会换行，文本会在在同一行上继续，直到遇到 <br> 标签为止。用以保证为单行文本</li>
<li>text-overflow: ellipsis; 使用显示省略符号来代表溢出的文本。</li>
</ol>
<p>效果如图：<br><img src="http://i2.muimg.com/567571/58e7e8d5d001d16a.png" alt=""></p>
<h2 id="多行文本溢出"><a href="#多行文本溢出" class="headerlink" title="多行文本溢出"></a>多行文本溢出</h2><h3 id="方法（一）"><a href="#方法（一）" class="headerlink" title="方法（一）"></a>方法（一）</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.multi-text</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</div><div class="line">    <span class="attribute">overflow</span>: hidden;</div><div class="line">    <span class="attribute">display</span>: -webkit-box;</div><div class="line">    <span class="attribute">-webkit-box-orient</span>: vertical;</div><div class="line">    <span class="attribute">-webkit-line-clamp</span>: <span class="number">3</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>-webkit-line-clamp 用来限制在一个块元素显示的文本的行数。为了实现该效果，它需要组合其他的 WebKit 属性。</li>
<li>display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示。</li>
<li>-webkit-box-orient; 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式。</li>
</ol>
<p>效果如图：<br><img src="http://i4.buimg.com/567571/751b758d27ab9971.png" alt=""></p>
<p>适用范围：<br>由于使用了 WebKit 的 CSS 扩展属性，该方法适用于 WebKit 浏览器及移动端，其中移动端大部分是 WebKit 内核的浏览器。</p>
<h3 id="方法（二）"><a href="#方法（二）" class="headerlink" title="方法（二）"></a>方法（二）</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.multi-text-complete</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">line-height</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">max-height</span>: <span class="number">60px</span>;   <span class="comment">/*将 height设为 line-height 的整数倍，防止超出的文字露出*/</span></div><div class="line">    <span class="attribute">overflow</span>: hidden;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.multi-text-complete</span><span class="selector-pseudo">:after</span> &#123;</div><div class="line">    <span class="attribute">content</span>: <span class="string">"..."</span>;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">padding-left</span>: <span class="number">40px</span>;</div><div class="line">    <span class="attribute">background</span>: <span class="built_in">-webkit-linear-gradient</span>(left, transparent, #fff 55%);</div><div class="line">    <span class="attribute">background</span>: <span class="built_in">-o-linear-gradient</span>(right, transparent, #fff 55%);</div><div class="line">    <span class="attribute">background</span>: <span class="built_in">-moz-linear-gradient</span>(right, transparent, #fff 55%);</div><div class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to right, transparent, #fff 55%);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>将 height 设置为 line-height 的整数倍，防止超出的文字露出。</li>
<li>给 p::after 添加渐变背景可避免文字只显示一半。</li>
<li>由于 ie6-7 不显示 content 内容，所以要添加标签兼容 ie6-7（如：<span>…<span>）；兼容ie8需要将 ::after 替换成 :after。</span></span></li>
</ol>
<p>效果如图：<br><img src="http://i1.piimg.com/567571/ea8ba4c779ae4ef7.png" alt=""></p>
<p>适用范围：该方法适用范围广，但文字未超出行的情况下也会出现省略号，可结合js优化该方法。</p>
<h2 id="源代码和运行效果"><a href="#源代码和运行效果" class="headerlink" title="源代码和运行效果"></a>源代码和运行效果</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>文本溢出显示省略号<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">        <span class="selector-class">.single-text</span> &#123;</div><div class="line">            <span class="attribute">width</span>: <span class="number">490px</span>;</div><div class="line">            <span class="attribute">overflow</span>: hidden;</div><div class="line">            <span class="attribute">text-overflow</span>: ellipsis;</div><div class="line">            <span class="attribute">white-space</span>: nowrap;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="selector-class">.multi-text</span> &#123;</div><div class="line">            <span class="attribute">width</span>: <span class="number">500px</span>;</div><div class="line">            <span class="attribute">overflow</span>: hidden;</div><div class="line">            <span class="attribute">display</span>: -webkit-box;</div><div class="line">            <span class="attribute">-webkit-box-orient</span>: vertical;</div><div class="line">            <span class="attribute">-webkit-line-clamp</span>: <span class="number">3</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="selector-class">.multi-text-complete</span> &#123;</div><div class="line">            <span class="attribute">width</span>: <span class="number">500px</span>;</div><div class="line">            <span class="attribute">position</span>: relative;</div><div class="line">            <span class="attribute">line-height</span>: <span class="number">20px</span>;</div><div class="line">            <span class="attribute">max-height</span>: <span class="number">60px</span>;</div><div class="line">            <span class="attribute">overflow</span>: hidden;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="selector-class">.multi-text-complete</span><span class="selector-pseudo">:after</span> &#123;</div><div class="line">            <span class="attribute">content</span>: <span class="string">"..."</span>;</div><div class="line">            <span class="attribute">position</span>: absolute;</div><div class="line">            <span class="attribute">bottom</span>: <span class="number">0</span>;</div><div class="line">            <span class="attribute">right</span>: <span class="number">0</span>;</div><div class="line">            <span class="attribute">padding-left</span>: <span class="number">40px</span>;</div><div class="line">            <span class="attribute">background</span>: <span class="built_in">-webkit-linear-gradient</span>(left, transparent, #fff 55%);</div><div class="line">            <span class="attribute">background</span>: <span class="built_in">-o-linear-gradient</span>(right, transparent, #fff 55%);</div><div class="line">            <span class="attribute">background</span>: <span class="built_in">-moz-linear-gradient</span>(right, transparent, #fff 55%);</div><div class="line">            <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to right, transparent, #fff 55%);</div><div class="line">        &#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"single-text"</span>&gt;</span></div><div class="line">        CSS实现单行文本溢出显示省略号CSS实现单行文本溢出显示省略号CSS实现单行文本溢出显示省略号CSS实现单行文本溢出显示省略号CSS实现单行文本溢出显示省略号CSS实现单行文本溢出显示省略号CSS实现单行文本溢出显示省略号</div><div class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"multi-text"</span>&gt;</span></div><div class="line">        CSS实现单行文本溢出显示省略号CSS实现单行文本溢出显示省略号CSS实现单行文本溢出显示省略号CSS实现单行文本溢出显示省略号CSS实现单行文本溢出显示省略号CSS实现单行文本溢出显示省略号CSS实现单行文本溢出显示省略号</div><div class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"multi-text-complete"</span>&gt;</span></div><div class="line">        CSS实现单行文本溢出显示省略号CSS实现单行文本溢出显示省略号CSS实现单行文本溢出显示省略号CSS实现单行文本溢出显示省略号CSS实现单行文本溢出显示省略号CSS实现单行文本溢出显示省略号CSS实现单行文本溢出显示省略号</div><div class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>效果如图：<br><img src="http://i4.buimg.com/567571/c83e04c2079c8b4f.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是在网易技术二面的时候面试官问到的一个问题，当时没有答出来，今天在这里作一次解决该问题方法的总结。&lt;/p&gt;
&lt;h2 id=&quot;单行文本溢出&quot;&gt;&lt;a href=&quot;#单行文本溢出&quot; class=&quot;headerlink&quot; title=&quot;单行文本溢出&quot;&gt;&lt;/a&gt;单行文本溢出&lt;/h2&gt;&lt;p&gt;可以使用 &lt;code&gt;text-overflow: ellipsis&lt;/code&gt; 属性来实现单行文本溢出显示省略号，当然还需要加宽度 &lt;code&gt;width&lt;/code&gt; 属性来兼容部分浏览器。&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.single-text&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;width&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;490px&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;overflow&lt;/span&gt;: hidden;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;text-overflow&lt;/span&gt;: ellipsis;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;white-space&lt;/span&gt;: nowrap;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://www.dengfuping.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://www.dengfuping.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>ES6 学习笔记（一）：spread operator（展开运算符）</title>
    <link href="http://www.dengfuping.com/2017/04/23/es6-spread-operator/"/>
    <id>http://www.dengfuping.com/2017/04/23/es6-spread-operator/</id>
    <published>2017-04-23T09:52:58.000Z</published>
    <updated>2017-05-02T11:33:13.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>ES6 中的 spread operator （展开运算符）是三个点（<code>...</code>）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])                 <span class="comment">// 1 2 3  </span></div><div class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)           <span class="comment">// 1 2 3 4 5  </span></div><div class="line">[...document.querySelectorAll(<span class="string">'div'</span>)]     <span class="comment">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>该运算符主要用于函数调用:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;  </div><div class="line">    array.push(...items);  </div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;  </div><div class="line">    <span class="keyword">return</span> x + y;  </div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="keyword">var</span> numbers = [<span class="number">4</span>, <span class="number">38</span>];  </div><div class="line">add(...numbers)             <span class="comment">// 42</span></div></pre></td></tr></table></figure>
<p>上面代码中，<code>array.push(...items)</code> 和 <code>add(...numbers)</code> 这两行，都是函数的调用，它们都使用了扩展运算符。该运算符将一个数组，变为参数序列。</p>
<p>扩展运算符与正常的函数参数可以结合使用，非常灵活:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">v, w, x, y, z</span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>];  </div><div class="line">f(<span class="number">-1</span>, ...args, <span class="number">2</span>, ...[<span class="number">3</span>]);</div></pre></td></tr></table></figure>
<h2 id="替代数组的-apply-方法"><a href="#替代数组的-apply-方法" class="headerlink" title="替代数组的 apply 方法"></a>替代数组的 apply 方法</h2><p>由于扩展运算符可以展开数组，所以不再需要 <code>apply</code> 方法将数组转为函数的参数了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5 的写法  </span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;  </div><div class="line"><span class="comment">// ...  </span></div><div class="line">&#125;  </div><div class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];  </div><div class="line">f.apply(<span class="literal">null</span>, args);</div><div class="line">  </div><div class="line"><span class="comment">// ES6 的写法  </span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;  </div><div class="line"><span class="comment">// ...  </span></div><div class="line">&#125;  </div><div class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];  </div><div class="line">f(...args);</div></pre></td></tr></table></figure>
<p>下面是扩展运算符取代 apply 方法的一个实际的例子，应用 <code>Math.max</code> 方法，简化求出一个数组最大元素的写法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5 的写法  </span></div><div class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])  </div><div class="line"><span class="comment">// ES6 的写法  </span></div><div class="line"><span class="built_in">Math</span>.max(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])  </div><div class="line"><span class="comment">//  等同于  </span></div><div class="line"><span class="built_in">Math</span>.max(<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>);</div></pre></td></tr></table></figure>
<p>上面代码表示，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用 Math.max 函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用 Math.max 了。</p>
<p>另一个例子是通过push函数，将一个数组添加到另一个数组的尾部:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5 的写法  </span></div><div class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</div><div class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"><span class="built_in">Array</span>.prototype.push.apply(arr1, arr2);</div><div class="line"> </div><div class="line"><span class="comment">// ES6 的写法  </span></div><div class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];  </div><div class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];  </div><div class="line">arr1.push(...arr2);</div></pre></td></tr></table></figure>
<p>上面代码的 ES5 写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。</p>
<p>下面是另外一个例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5  </span></div><div class="line"><span class="keyword">new</span> (<span class="built_in">Date</span>.bind.apply(<span class="built_in">Date</span>, [<span class="literal">null</span>, <span class="number">2015</span>, <span class="number">1</span>, <span class="number">1</span>]));</div><div class="line"> </div><div class="line"><span class="comment">// ES6  </span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(...[<span class="number">2015</span>, <span class="number">1</span>, <span class="number">1</span>]);</div></pre></td></tr></table></figure>
<h2 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h2><h3 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h3><p>扩展运算符提供了数组合并的新写法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5  </span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>].concat(more)</div><div class="line"></div><div class="line"><span class="comment">// ES6  </span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, ...more]  </div><div class="line"><span class="keyword">var</span> arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>];  </div><div class="line"><span class="keyword">var</span> arr2 = [<span class="string">'c'</span>];  </div><div class="line"><span class="keyword">var</span> arr3 = [<span class="string">'d'</span>, <span class="string">'e'</span>];</div><div class="line"> </div><div class="line"><span class="comment">// ES5 的合并数组  </span></div><div class="line">arr1.concat(arr2, arr3);        <span class="comment">// [ 'a', 'b', 'c', 'd', 'e' ]  </span></div><div class="line"><span class="comment">// ES6 的合并数组  </span></div><div class="line">[...arr1, ...arr2, ...arr3]     <span class="comment">// [ 'a', 'b', 'c', 'd', 'e' ]</span></div></pre></td></tr></table></figure>
<h3 id="与-ES6-中的解构赋值结合"><a href="#与-ES6-中的解构赋值结合" class="headerlink" title="与 ES6 中的解构赋值结合"></a>与 ES6 中的解构赋值结合</h3><p>扩展运算符可以与解构赋值结合起来，用于生成数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5  </span></div><div class="line">a = list[<span class="number">0</span>], rest = list.slice(<span class="number">1</span>)  </div><div class="line"><span class="comment">// ES6  </span></div><div class="line">[a, ...rest] = list</div></pre></td></tr></table></figure>
<p>下面是另外一些例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];  </div><div class="line">first      <span class="comment">// 1  </span></div><div class="line">rest       <span class="comment">// [2, 3, 4, 5]</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> [first, ...rest] = [];  </div><div class="line">first      <span class="comment">// undefined  </span></div><div class="line">rest       <span class="comment">// []</span></div><div class="line">  </div><div class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="string">"foo"</span>];  </div><div class="line">first      <span class="comment">// "foo"  </span></div><div class="line">rest       <span class="comment">// []</span></div></pre></td></tr></table></figure>
<p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> [...butLast, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];          <span class="comment">//  报错  </span></div><div class="line"><span class="keyword">const</span> [first, ...middle, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];    <span class="comment">//  报错</span></div></pre></td></tr></table></figure>
<h3 id="函数返回多个值"><a href="#函数返回多个值" class="headerlink" title="函数返回多个值"></a>函数返回多个值</h3><p>JavaScript 的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dateFields = readDateFields(database);  </div><div class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(...dateFields);</div></pre></td></tr></table></figure>
<p>上面代码从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数Date。</p>
<h3 id="转换字符串为数组"><a href="#转换字符串为数组" class="headerlink" title="转换字符串为数组"></a>转换字符串为数组</h3><p>扩展运算符还可以将字符串转为真正的数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[...<span class="string">'hello'</span>]        <span class="comment">// [ "h", "e", "l", "l", "o" ]</span></div></pre></td></tr></table></figure>
<p>上面的写法，有一个重要的好处，那就是能够正确识别 32 位的 Unicode 字符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'x\uD83D\uDE80y'</span>.length         <span class="comment">// 4  </span></div><div class="line">[...<span class="string">'x\uD83D\uDE80y'</span>].length    <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>上面代码的第一种写法， JavaScript 会将 32 位 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">length</span>(<span class="params">str</span>) </span>&#123;  </div><div class="line">    <span class="keyword">return</span> [...str].length;  </div><div class="line">&#125;</div><div class="line"></div><div class="line">length(<span class="string">'x\uD83D\uDE80y'</span>)         <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>凡是涉及到操作 32 位 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> str = <span class="string">'x\uD83D\uDE80y'</span>;  </div><div class="line">str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)  <span class="comment">// 'y\uDE80\uD83Dx'  </span></div><div class="line">[...str].reverse().join(<span class="string">''</span>)       <span class="comment">// 'y\uD83D\uDE80x'</span></div></pre></td></tr></table></figure>
<p>上面代码中，如果不用扩展运算符，字符串的reverse操作就不正确。</p>
<h3 id="将-Iterator-接口对象转换为数组"><a href="#将-Iterator-接口对象转换为数组" class="headerlink" title="将 Iterator 接口对象转换为数组"></a>将 Iterator 接口对象转换为数组</h3><p>任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> nodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);  </div><div class="line"><span class="keyword">var</span> array = [...nodeList];</div></pre></td></tr></table></figure>
<p>上面代码中，querySelectorAll方法返回的是一个nodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了 Iterator 接口。</p>
<p>对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arrayLike = &#123;  </div><div class="line">    <span class="string">'0'</span>: <span class="string">'a'</span>,  </div><div class="line">    <span class="string">'1'</span>: <span class="string">'b'</span>,  </div><div class="line">    <span class="string">'2'</span>: <span class="string">'c'</span>,  </div><div class="line">    <span class="attr">length</span>: <span class="number">3</span>  </div><div class="line">&#125;;</div><div class="line">    </div><div class="line"><span class="keyword">let</span> arr = [...arrayLike];    <span class="comment">// TypeError: Cannot spread non-iterable object.</span></div></pre></td></tr></table></figure>
<p>上面代码中，arrayLike 是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用 <code>Array.from</code> 方法将 <code>arrayLike</code> 转为真正的数组。</p>
<h3 id="Map、Set-和-Generator-函数"><a href="#Map、Set-和-Generator-函数" class="headerlink" title="Map、Set 和 Generator 函数"></a>Map、Set 和 Generator 函数</h3><p>扩展运算符内部调用的是数据结构的 <code>Iterator</code> 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([  </div><div class="line">    [<span class="number">1</span>, <span class="string">'one'</span>],  </div><div class="line">    [<span class="number">2</span>, <span class="string">'two'</span>],  </div><div class="line">    [<span class="number">3</span>, <span class="string">'three'</span>],  </div><div class="line">]);</div><div class="line">  </div><div class="line"><span class="keyword">let</span> arr = [...map.keys()];       <span class="comment">// [1, 2, 3]</span></div></pre></td></tr></table></figure>
<p>Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> go = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;  </div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;  </div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span>;  </div><div class="line">    <span class="keyword">yield</span> <span class="number">3</span>;  </div><div class="line">&#125;;</div><div class="line"> </div><div class="line">[...go()];        <span class="comment">// [1, 2, 3]</span></div></pre></td></tr></table></figure>
<p>上面代码中，变量 go 是一个 <code>Generator</code> 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</p>
<p>如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;  </div><div class="line"><span class="keyword">let</span> arr = [...obj];    <span class="comment">// TypeError: Cannot spread non-iterable object</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;含义&quot;&gt;&lt;a href=&quot;#含义&quot; class=&quot;headerlink&quot; title=&quot;含义&quot;&gt;&lt;/a&gt;含义&lt;/h2&gt;&lt;p&gt;ES6 中的 spread operator （展开运算符）是三个点（&lt;code&gt;...&lt;/code&gt;）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(...[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;])                 &lt;span class=&quot;comment&quot;&gt;// 1 2 3  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, ...[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)           &lt;span class=&quot;comment&quot;&gt;// 1 2 3 4 5  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[...document.querySelectorAll(&lt;span class=&quot;string&quot;&gt;&#39;div&#39;&lt;/span&gt;)]     &lt;span class=&quot;comment&quot;&gt;// [&amp;lt;div&amp;gt;, &amp;lt;div&amp;gt;, &amp;lt;div&amp;gt;]&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="ES6学习笔记" scheme="http://www.dengfuping.com/categories/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ES6" scheme="http://www.dengfuping.com/tags/ES6/"/>
    
      <category term="ECMAScript 6" scheme="http://www.dengfuping.com/tags/ECMAScript-6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript：判断某个对象是否为数组的四种方法</title>
    <link href="http://www.dengfuping.com/2017/04/21/javascript-judge-object-is-array-or-not/"/>
    <id>http://www.dengfuping.com/2017/04/21/javascript-judge-object-is-array-or-not/</id>
    <published>2017-04-21T12:41:13.000Z</published>
    <updated>2017-05-02T10:12:19.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="instanceof-操作符（有限制）"><a href="#instanceof-操作符（有限制）" class="headerlink" title="instanceof 操作符（有限制）"></a>instanceof 操作符（有限制）</h2><p>我们可以使用 instanceof 操作符来检测某个对象是否是数组的实例，该检测会返回一个布尔型值(boolean)。如果是数组的话，返回 true，否则的话返回 false</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>);      <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="regexp">/\d+/g</span> <span class="keyword">instanceof</span> <span class="built_in">Array</span>);  <span class="comment">// false</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>使用 instanceof 操作符有一个问题就是，它假定只有一个全局作用域。如果一个网页中有多个框架（iframe 元素），那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的 Array 构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。传入的数组在该框架中用 instanceof 操作符判断就会返回 false。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> b = [];</div><div class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> <span class="built_in">Object</span>);              <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> <span class="built_in">Array</span>);               <span class="comment">//true</span></div><div class="line">  </div><div class="line"><span class="keyword">var</span> frame = <span class="built_in">document</span>.createElement(<span class="string">"iframe"</span>);  <span class="comment">//创建一个框架</span></div><div class="line"><span class="built_in">document</span>.body.appendChild(frame);</div><div class="line"><span class="keyword">var</span> c = <span class="built_in">window</span>.frames[<span class="number">0</span>].Array;                <span class="comment">//取得框架全局执行环境中的Array构造函数</span></div><div class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> c();                               <span class="comment">//在框架全局执行环境中创建一个数组d</span></div><div class="line"></div><div class="line"><span class="comment">//在当前页面的执行环境中用instanceof 操作符判断 d 是否为数组，返回 false</span></div><div class="line"><span class="built_in">console</span>.log(d <span class="keyword">instanceof</span> <span class="built_in">Array</span>);   </div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(d));                 <span class="comment">//true</span></div></pre></td></tr></table></figure>
<h2 id="constructor-属性（有限制）"><a href="#constructor-属性（有限制）" class="headerlink" title="constructor 属性（有限制）"></a>constructor 属性（有限制）</h2><p>在javascript中，每个对象都有一个constructor属性，它引用了初始化该对象的构造函数，比如判断未知对象的类型，因此我们可以通过如下方法进行判断：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myIsArray</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> obj == <span class="string">'object'</span> &amp;&amp; obj.constructor == <span class="built_in">Array</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与使用 instanceof 操作符一样，当存在多个全局作用域时，使用constructor 属性无法进行判断。</p>
<h2 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h2><p>使用 <code>ES 5</code> 新增的Array.isArray()方法。这个方法的作用就是确定某个值到底是不是数组，而不管它到底是在哪个全局执行环境中创建的。</p>
<h2 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h2><p>该方法返回一个 <code>[object NativeConstructorName]</code> 格式的字符串。每个类在内部都有一个 <code>[[Class]]</code> 属性，这个属性中就指定了上述字符串中的构造函数名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myIsArray</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) == <span class="string">'[object Array]'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;instanceof-操作符（有限制）&quot;&gt;&lt;a href=&quot;#instanceof-操作符（有限制）&quot; class=&quot;headerlink&quot; title=&quot;instanceof 操作符（有限制）&quot;&gt;&lt;/a&gt;instanceof 操作符（有限制）&lt;/h2&gt;&lt;p&gt;我们可以使用 instanceof 操作符来检测某个对象是否是数组的实例，该检测会返回一个布尔型值(boolean)。如果是数组的话，返回 true，否则的话返回 false&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log([] &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;);      &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;regexp&quot;&gt;/\d+/g&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;);  &lt;span class=&quot;comment&quot;&gt;// false&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript：常用基础函数解析</title>
    <link href="http://www.dengfuping.com/2017/04/21/javascript-basic-function/"/>
    <id>http://www.dengfuping.com/2017/04/21/javascript-basic-function/</id>
    <published>2017-04-21T11:45:54.000Z</published>
    <updated>2017-05-02T10:11:47.358Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://i1.piimg.com/567571/ffcf817d274532d9.png" alt=""></p>
<p>此文主要是对 JavaScript 的常用函数做一个总结和解析，方便理解和参考。</p>
<a id="more"></a>
<h2 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h2><ul>
<li>操作对象：Array 和 String 对象</li>
<li>原对象是否变化：<code>不变化</code></li>
<li>函数用法：slice(start, end)</li>
<li>函数功能：对数组或字符串进行 <code>截取</code> ，并返回一个数组副本。即原数组或字符串 <code>不会被修改</code> 。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</div><div class="line"><span class="keyword">var</span> b = a.slice(<span class="number">0</span>, <span class="number">3</span>);  <span class="comment">// b = [1,2,3]</span></div><div class="line"></div><div class="line"><span class="comment">//如果不传入参数二，那么将从参数一的索引位置开始截取，一直到数组或字符串结尾</span></div><div class="line"><span class="keyword">var</span> c = a.slice(<span class="number">3</span>);     <span class="comment">// c = [4,5,6]</span></div><div class="line"></div><div class="line"><span class="comment">// 此时数组 a = [1, 2, 3, 4, 5, 6]</span></div></pre></td></tr></table></figure>
<h2 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h2><ul>
<li>操作对象：String 对象</li>
<li>原对象是否发生变化：<code>不变化</code></li>
<li>函数用法：split(start, end)</li>
<li>函数功能：把这个字符串分割成片段来创建一个字符串数组。可选参数 <code>limit</code> 可以限制被分割的片段数量。<code>separator</code> 参数可以是一个字符串或一个正则表达式。如果 <code>separator</code> 是一个空字符，会返回一个单字符的数组。<code>可以将一个字符串变为数组</code> 。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="string">"Hello World Are You Ok"</span>;</div><div class="line"><span class="keyword">var</span> b = a.split(<span class="string">" "</span>);        <span class="comment">// 分隔符为一个空格，返回 ["Hello", "World", "Are", "You", "Ok"]</span></div><div class="line"><span class="keyword">var</span> c = a.split(<span class="string">" "</span>, <span class="number">2</span>);     <span class="comment">// 分隔符为一个空格，且设置 limit 参数，则返回 ["Hello", "World"]</span></div><div class="line"><span class="keyword">var</span> d = a.split(<span class="string">""</span>);        <span class="comment">// 分隔符为空字符，返回 ["H", "e", "l", ... , "O", "k"]</span></div></pre></td></tr></table></figure>
<h2 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h2><ul>
<li>操作对象：Array 对象</li>
<li>原对象是否发生变化：<code>不变化</code></li>
<li>函数用法：splice(start, deleteCount, item1, item2,…)</li>
<li>函数功能：参数 <code>start</code> 是从数组中移除元素的开始位置。参数 <code>deleteCount</code> 是要移除的元素的个数。后面的 item1, item2…是可选参数，表示会插入到被移除元素的位置上。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</div><div class="line"><span class="keyword">var</span> b = a.splice(<span class="number">1</span>, <span class="number">1</span>, <span class="string">'e'</span>, <span class="string">'f'</span>);  <span class="comment">//a = ['a', 'e', 'f', 'c'], b = ['b']</span></div></pre></td></tr></table></figure>
<h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><ul>
<li>操作对象：Array 对象</li>
<li>原对象是否发生变化：<code>变化</code></li>
<li>函数用法：splice(separator)</li>
<li>函数功能：把数组中的所有元素放入一个字符串，并使用指定的分隔符进行分隔的。其中 separator 为可选可选参数，指定要使用的分隔符。如果省略该参数，则使用 <code>逗号</code> 作为分隔符。 <code>可以将一个数组变为字符串</code> 。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> b = a.join(<span class="string">"&amp;"</span>);  <span class="comment">//  a = [1, 2, 3, 4, 5], b = "1&amp;2&amp;3&amp;4&amp;5"</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://i1.piimg.com/567571/ffcf817d274532d9.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;此文主要是对 JavaScript 的常用函数做一个总结和解析，方便理解和参考。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.dengfuping.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>腾讯 2017 暑期实习生招聘电话一面总结</title>
    <link href="http://www.dengfuping.com/2017/03/28/tencent-the-first-interview-summary/"/>
    <id>http://www.dengfuping.com/2017/03/28/tencent-the-first-interview-summary/</id>
    <published>2017-03-28T09:32:24.000Z</published>
    <updated>2017-03-29T09:53:46.065Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://i2.muimg.com/567571/12498fa06454beda.png" alt=""><br>我是3月份在牛客网上找腾讯的内部员工内推的，当时就把自己的个人信息（姓名-邮箱-电话-学校）和自己的简历用邮箱发给他，然后第二天就收到了内推的邮件，要求在腾讯的官网上完善自己的简历。我申请的是 <code>前端开发</code> 的暑期实习生岗位。<a id="more"></a></p>
<p>后来看腾讯的招聘流程，发现4月2号和3号有在线笔试，我还以为腾讯的内推也要经过笔试呢。今天快中午的时候接到了腾讯面试官的电话，问我现在方不方便面试，正好那个时候我翘掉了毛概，想想再约时间也一样，就说现在就可以开始。以下是面试时的问题总结：</p>
<ol>
<li><p>开始就问我做过哪些项目。由于我只做过自己的一些个人项目和 demo，没有过正式的项目经验，所以就直接说没有。不过谈到了我最近自己在鼓捣的一个仿知乎类的一个问答网站，主要是讲了用到了哪些技术，遇到的难点是什么。其中说到的 <code>Vue.js</code>，面试官问有没有看过它的源代码，知不知道它的实现原理。哈哈，这就 gg 了。数据绑定的实现原理好像看到过，但记得不是很深，就胡乱答了一通，感觉不是很好。</p>
</li>
<li><p>谈谈你对浏览器兼容问题的看法</p>
</li>
<li><p><code>http</code> 和 <code>https</code> 的区别（我说的是 <code>https</code> 是 <code>http</code> + <code>SSL</code>,比传统的 <code>http</code> 更加安全），然后面试官又接着问为什么 <code>https</code> 更安全，要求说出原理和指出具体的发送过程（我只知道需要公钥私钥一起才能实现对加密传输的信息进行解密，一问到具体的发送过程就不知道了）。</p>
</li>
<li><p>在浏览器中输入网页地址并进行访问的流程是什么？这是前两年的面试题了，恰好之前准备面试的时候专门复习过，所以流程答得还不错。但当我谈到查找缓存的时候，他就让我说查找缓存的原理是什么。这就尴尬了，反正就照着自己的理解答了一下。但一直被追问底层原理，所以个人感觉答得不是很好。</p>
</li>
<li><p>有哪些实现缓存的方法？（由于我只知道实现浏览器本地缓存的方法，所以就答了 <code>cookie</code>、<code>sessionStorage</code>、<code>localStorage</code>这三个）</p>
</li>
<li><p><code>ES6</code> 中的 <code>promise</code> 对象，作用是什么？</p>
</li>
<li><p>前端优化问题，有哪些优化或提高性能的方法？</p>
</li>
<li><p>谈谈你对分布式系统的理解。发送网络请求时如何选择请求的网络服务器？是按照什么原则进行选择的？</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://i2.muimg.com/567571/12498fa06454beda.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;我是3月份在牛客网上找腾讯的内部员工内推的，当时就把自己的个人信息（姓名-邮箱-电话-学校）和自己的简历用邮箱发给他，然后第二天就收到了内推的邮件，要求在腾讯的官网上完善自己的简历。我申请的是 &lt;code&gt;前端开发&lt;/code&gt; 的暑期实习生岗位。
    
    </summary>
    
      <category term="面试总结" scheme="http://www.dengfuping.com/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="腾讯" scheme="http://www.dengfuping.com/tags/%E8%85%BE%E8%AE%AF/"/>
    
      <category term="面试" scheme="http://www.dengfuping.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="前端" scheme="http://www.dengfuping.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB学习笔记（二）：常见问题和常用技巧</title>
    <link href="http://www.dengfuping.com/2017/02/04/mongodb-learning-2/"/>
    <id>http://www.dengfuping.com/2017/02/04/mongodb-learning-2/</id>
    <published>2017-02-04T05:44:11.000Z</published>
    <updated>2017-02-04T08:17:25.748Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用pretty-方法格式化输出数据"><a href="#使用pretty-方法格式化输出数据" class="headerlink" title="使用pretty()方法格式化输出数据"></a>使用pretty()方法格式化输出数据</h3><p>使用 db.collection_name.find() 是以非结构化的方式返回数据，每一条占一整行，一点格式都没有，很难阅读。<br><img src="http://p1.bpimg.com/567571/fe3fc2378bab0ae9.png" alt=""><a id="more"></a></p>
<p>如果你需要以易读的方式来读取数据，可以使用 pretty() 方法，语法格式如下：db.collection_name.find().pretty()<br><img src="http://p1.bpimg.com/567571/0a0a728416a3034e.png" alt=""></p>
<p>当然，你也可以使用在MongoDB shell执行以下命令将全局的数据输出都格式化，这样也就不用每次都调用pretty()方法了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &quot;DBQuery.prototype._prettyShell = true&quot; &gt;&gt; ~/.mongorc.js</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;使用pretty-方法格式化输出数据&quot;&gt;&lt;a href=&quot;#使用pretty-方法格式化输出数据&quot; class=&quot;headerlink&quot; title=&quot;使用pretty()方法格式化输出数据&quot;&gt;&lt;/a&gt;使用pretty()方法格式化输出数据&lt;/h3&gt;&lt;p&gt;使用 db.collection_name.find() 是以非结构化的方式返回数据，每一条占一整行，一点格式都没有，很难阅读。&lt;br&gt;&lt;img src=&quot;http://p1.bpimg.com/567571/fe3fc2378bab0ae9.png&quot; alt=&quot;&quot;&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.dengfuping.com/categories/MongoDB/"/>
    
    
      <category term="数据库" scheme="http://www.dengfuping.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MongoDB" scheme="http://www.dengfuping.com/tags/MongoDB/"/>
    
      <category term="NoSQL" scheme="http://www.dengfuping.com/tags/NoSQL/"/>
    
  </entry>
  
</feed>
